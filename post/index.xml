<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My Blog</title>
    <link>https://seconsorl.github.io/post/</link>
    <description>Recent content in Posts on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>216002917@nbu.edu.cn (HZW)</managingEditor>
    <webMaster>216002917@nbu.edu.cn (HZW)</webMaster>
    <lastBuildDate>Mon, 08 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://seconsorl.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>傅里叶变换</title>
      <link>https://seconsorl.github.io/post/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2fourier-transform/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2fourier-transform/</guid>
      <description>傅里叶变换 傅里叶级数 介绍 $\sin(kx)$与$\cos(nx)$在一个周期内是两两正交的： $$ \int_{-\pi}^{\pi}\sin(kx)\sin(nx)dx=0(n\ne k)=\pi(n=k) $$ $$ \int_{-\pi}^{\pi}\cos(kx)\cos(nx)dx=0(n\ne k)=\pi(n=k) $$ $$ \int_{-\pi}^{\pi}\sin(kx)\cos(nx)dx=0 $$ 因为被积函数是奇函数。&#xA;因此，$\sin(kx)$与$\cos(nx)$为函数空间的一组正交基。函数空间（此处应为希尔伯特空间:完备的内积空间）中任何一个函数都可以用这些基来表示，就如三维欧式空间中任何一个向量都可以用$x,y,z$来表示。&#xA;不同之处在于对于函数的表示是无穷维的，比如方波函数$SW(x)$：&#xA;它的傅里叶级数可以表示为： $$ SW(x)=b_1 \sin x+b_2 \sin(2x)+b_3 \sin(3x)+\dots =\sum_{n=1}^{\infty}b_n \sin(nx) $$ 求各系数非常简单，方程两边同乘$\sin(kx)$，然后在一个周期内积分，可得： $$ b_k=\frac{1}{\pi}\int_{-\pi}^{\pi}SW(x)\sin(kx)dx=\frac{2}{\pi}\int_0^{\pi}\sin(kx)dx=\frac{2}{\pi}|\frac{-\cos(kx)}{k}|_{0}^{\pi} \ =\frac{2}{\pi}{ \frac{2}{1},\frac{0}{2},\frac{2}{3}\dots } $$&#xA;$$ SW(x)=\frac{4}{\pi}(\frac{\sin x}{1}+\frac{\sin(3x)}{3}+\frac{\sin(5x)}{5}+\dots) $$&#xA;注意：在靠近间断点x=0处，随着所用项（基）的增多，波动(overshoot)越来越靠近间断点，这种现象叫做吉布斯现象(Gibbs phenomenon)。只能减小其影响，但无法避免，这是处理不连续函数的一个巨大障碍。&#xA;吉布斯现象的典故：【英文大意：在刚要进入本世纪的时候, 一位美国物理学家 A．Michelson 制造了一部机器,借助于这部机器可以求得以图像给出的函数的头 80 个傅里叶分量．机器分析所得的这一结果可以通过下列方法进行检验, 即把所求得的分量加在一起, 看看这样得到的函数是否接近于原来的函数．在大多数情况中, 它是正确的; 但是当用于方波函数 S(x) 的时候, 在它的间断点处 “出现了一个原来函数中不存在的奇怪的突点．Michelson 感到迷惑不解, 猜想也许是机器的某个隐藏着的缺陷引起的毛病．他把他的观察写信告诉了著名的数学物理学家 Josiah Gibbs, 征求他的意见．Gibbs研究了这个现象, 并解释了这个现象 (发表在 1899 年给《自然》的一篇通讯中)。】&#xA;类似地，对于偶函数，只需用$\cos(nx)$表示&#xA;一般地，任何一个函数 $f(x)\subset C([−\pi,\pi])$ (既不是奇函数，也不是偶函数)可以表示为： $$ f(x)=a_0+\sum_{n=1}^{\infty}a_n \cos(nx)+\sum_{n=1}^{\infty}b_n \sin(nx) $$ 求各系数特别简单，等式两边分别同乘$1,\cos(kx),\sin(kx)$，然后在一个周期内积分可得$a_0,a_k,b_k$，即： $$ a_0=\frac{1}{2\pi}\int_{-\pi}^{\pi}f(x)dx,\ a_k=\frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\cos(kx)dx,\ b_k=\frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\sin(kx)dx $$ 进一步，推广到复数域。我们知道$e^{-ikx}$与$e^{inx}$是正交的（内积为0），即： $$ \int_{-\pi}^{\pi}e^{-ikx}e^{ink}dx=|\frac{e^{i(n-k)x}}{i(n-k)}|{-\pi}^{\pi}=0 (n\ne k) $$ 也就是说$e^{ikx}$是希尔伯特空间的一组正交基。此处复数内积运算，需乘其共轭 $e^{-ikx}$。则任何一个周期函数$f(x)$可以表示为： $$ f(x)=\sum{n=-\infty}^{\infty}c_ne^{inx} $$ 求$c_k$，则可以两边同时乘上$e^{-ikx}$，然后在一个周期内积分可得： $$ \int_{-\pi}^{\pi}f(x)e^{-ikx}dx=\int_{-\pi}^{\pi}c_0e^{-ikx}dx+\int_{-\pi}^{\pi}c_1e^{ix}e^{-ikx}dx+\int_{-\pi}^{\pi}c_{-1}e^{-ix}e^{-ikx}dx\ \dots+\int_{-\pi}^{\pi}c_ke^{ikx}e^{-ikx}dx+\dots $$ 右边只有$\int_{-\pi}^{\pi}c_ke^{ikx}e^{-ikx}dx=2\pi c_k$，其他都为0，即：&#xA;$c_k=\frac{1}{2\pi}\int_{-\pi}^{\pi}f(x)e^{-ikx}dx$</description>
    </item>
    <item>
      <title>qemu</title>
      <link>https://seconsorl.github.io/post/qemu/</link>
      <pubDate>Mon, 08 Jul 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/qemu/</guid>
      <description>TIPS 官方文档&#xA;qemu Note&#xA;使用 QEMU 命令行的一般形式可以表示为：&#xA;$ qemu-system-x86_64 [机器选项] \ [CPU 选项] \ [加速器选择] \ [设备选择] \ [后端选择] \ [接口选项] \ [启动选项] 大多数选项都会生成一些帮助信息。例如：&#xA;$ qemu-system-x86_64 -M help 将列出该 QEMU 二进制文件支持的机器类型。help 也可以作为参数传递给其他选项。例如：&#xA;$ qemu-system-x86_64 -device scsi-hd，help 将列出可以控制设备行为的附加选项的参数及其默认值scsi-hd。&#xA;参数解释&#xA;选项 机器（Machine） 定义机器类型、内存量等 CPU vCPU 的类型和数量/拓扑。大多数加速器都提供hostCPU 选项，该选项会直接传递主机 CPU 配置，而不会过滤任何功能。 加速器（Accelerator） 这取决于您运行的虚拟机管理程序。默认设置是 TCG，它是纯模拟的，因此您必须指定加速器类型才能利用硬件虚拟化。 设备（Devices） 机器类型中默认未定义的附加设备。 后端（Backends） 后端是 QEMU 处理客户机数据的方式，例如块设备如何存储、网络设备如何查看网络或串行设备如何指向外部。 接口（Interfaces） 系统如何显示，如何管理和控制或调试。 引导（Boot） 系统如何启动，通过固件还是直接内核启动。 示例#1 首先定义一台virt机器，它是用于运行 aarch64 客户机的通用平台。我们启用虚拟化功能，以便在模拟客户机中使用 KVM。由于 virt机器自带一些 pflash 设备，我们为它们命名，以便稍后覆盖默认值。&#xA;$ qemu-system-aarch64 \&#xD;-machine type=virt,virtualization=on,pflash0=rom,pflash1=efivars \&#xD;-m 4096 \ 使用选项定义 4 个 vCPU，max该选项提供了 QEMU 能够模拟的所有 Arm 功能。我们启用了更易于模拟的 Arm 指针认证算法实现。我们明确指定了 TCG 加速，尽管 QEMU 默认会使用 TCG 加速。&#xA;-cpu max \&#xD;-smp 4 \&#xD;-accel tcg \ 由于virt平台没有任何默认的网络或存储设备，我们需要定义它们。我们为它们分配 ID，以便稍后将它们与后端连接起来。</description>
    </item>
    <item>
      <title>CSS</title>
      <link>https://seconsorl.github.io/post/css/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/css/</guid>
      <description>CSS(Cascading Style Sheet)层叠样式表 TIPS 链接 CSS_菜鸟教程 W3school&#xA;查看网页样式 审查元素|开发者模式（F12） -&amp;gt; 元素 -&amp;gt; 右边的样式&#xA;正则 = 绝对等于 *= 包含这个元素 ^=以这个开头 $=以这个结尾 div 主要用来设置一块一块区域的&#xA;不加宽度设置，默认和上一级一样宽&#xA;img 默认内联元素&#xA;图片居中可以设置为在外面套一个div，设置display:block；再margin:0 auto;即可 或者 外层添加text-align属性 center&#xA;span 主要用于设置一段文字&#xA;CSS预处理器 CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。就是用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用。&#xA;SASS：基于Ruby，通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。&#xA;LESS：基于NodeJS，通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS，但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用LESS。&#xA;简介 发展史 CSS 1.0：基本&#xA;CSS 2.0：DIV（块）+CSS，HTML 与 CSS 结构分离的思想，利于SEO&#xA;CSS 2.1：浮动，定位&#xA;CSS 3.0：圆角边框，阴影，动画&amp;hellip; 浏览器兼容性~&#xA;格式 文件目录格式 CSS-&amp;gt; .css文件&#xA;.html文件&#xA;内容格式 行内样式 在标签中写style=&amp;quot; &amp;ldquo;，仅对当前标签生效 &amp;lt;h1 style=&amp;#34;color:red&amp;#34;&amp;gt; 1 &amp;lt;/h1&amp;gt; 内部样式 在HTML文件中写：在head标签里加入style标签，在style中写CSS代码 style标签中加CSS代码，和HTML不同 style标签中的注释格式 /* */ &amp;lt;style&amp;gt; h1{ color:red; border-radius:10px; } &amp;lt;/style&amp;gt; 外部样式 在CSS文件中写：不需要加style标签，直接写。 HTML引用CSS（在head标签）： &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;文件路径&amp;#34;&amp;gt; &amp;lt;style&amp;gt; @import url(&amp;#34;路径&amp;#34;); /*CSS2.1 特有 不建议*/ &amp;lt;/style&amp;gt; 语法 样式的优先级：行内样式 &amp;gt; （就近原则）内部样式、外部样式&#xA;选择器1 [选择器2 [选择器3]] { 声明1; 声明2; } color:#6位16进制数; (RGB) &amp;lt;!</description>
    </item>
    <item>
      <title>DeepLearning</title>
      <link>https://seconsorl.github.io/post/deeplearning/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/deeplearning/</guid>
      <description>TIPS 机器学习模型训练的步骤：&#xA;1、数据模块（数据采集，清洗，处理等） 2、建立模型（各种模型的建立） 3、损失函数的选择（根据不同的任务选择不同的损失函数），有了loss就可以求取梯度 4、得到梯度之后，我们会选择某种优化方式去进行优化 5、然后迭代训练 线性回归 介绍 线性回归是分析一个变量与另外一(多)个变量之间关系的方法。因变量是$y$，自变量是$x$，关系线性 $$ y=w\times x +b $$ 任务就是求解$w$，$b$。&#xA;求解步骤： 确定模型&#xA;选择损失函数：这里用MSE $$ \frac{1}{m} \sum_{i=1}^{m}(y_i-\hat{y_i}) $$&#xA;求解梯度并更新$w$，$b$ $$ w = w - LR \times w.grad \ b = b - LR \times w.grad $$&#xA;代码 # 首先我们得有训练样本X，Y， 这里我们随机生成 x = torch.rand(20, 1) * 10 y = 2 * x + (5 + torch.randn(20, 1)) # 构建线性回归函数的参数 w = torch.randn((1), requires_grad=True) b = torch.zeros((1), requires_grad=True) # 这俩都需要求梯度 for iteration in range(100): # 前向传播 wx = torch.mul(w, x) y_pred = torch.add(wx, b) # 计算loss loss = (0.5 * (y-y_pred)**2).mean() # 反向传播 loss.backward() # 更新参数 b.data.sub_(lr * b.</description>
    </item>
    <item>
      <title>docker compose</title>
      <link>https://seconsorl.github.io/post/docker-compose/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/docker-compose/</guid>
      <description>TIPS 菜鸟教程&#xA;入门&#xA;docker网络1&#xA;docker网络2&#xA;介绍 Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。&#xA;YML 文件配置介绍 YAML。&#xA;Compose 使用的三个步骤：&#xA;使用 Dockerfile 定义应用程序的环境。 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。 最后，执行 docker-compose up 命令来启动并运行整个应用程序。 docker-compose.yml 的配置案例如下（配置参数参考下文）：&#xA;实例&#xA;# yaml 配置实例 version: &amp;#39;3&amp;#39; services: web: build: . ports: - &amp;#34;5000:5000&amp;#34; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} 安装 Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：https://github.com/docker/compose/releases。&#xA;运行以下命令以下载 Docker Compose 的当前稳定版本：&#xA;$ sudo curl -L &amp;#34;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose Docker Compose 存放在 GitHub，不太稳定。&#xA;你可以也通过执行下面的命令，高速安装 Docker Compose。&#xA;curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose 将可执行权限应用于二进制文件：&#xA;$ sudo chmod +x /usr/local/bin/docker-compose 创建软链：&#xA;$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 测试是否安装成功：</description>
    </item>
    <item>
      <title>EndNote21</title>
      <link>https://seconsorl.github.io/post/endnote21/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/endnote21/</guid>
      <description>TIPS https://zhuanlan.zhihu.com/p/709132184&#xA;https://zhuanlan.zhihu.com/p/489154935&#xA;下载和安装 网上找下载地址，下载软件并安装。&#xA;**注意：**以管理员方式运行安装程序&#xA;激活码&#xA;淘宝上找商家（也会提供软件下载地址），几元钱解决&#xA;EndNote 21新功能概览 使用标签（Tag）整理&#xA;可以自定义标签，以此分类&#xA;文献恢复功能&#xA;因为有云端存储&#xA;全新EndNote Web&#xA;类似于Online版本，但是只有21版本有这个&#xA;可以与 1,000 位合作伙伴共享&#xA;主要功能与界面介绍 1、最上方是菜单栏&#xA;2、左侧导航栏（包含数据库管理、分组、在线检索）&#xA;3、中间文献总览（上部为检索工具栏，下部为文献列表）&#xA;4、所选择的文献的详细信息&#xA;左侧导航栏 同步设置（Synv Configuration） 显示所有的参考文献（All References） 最近添加（Recently Added）：右键可以选择&amp;quot;最近多少天&amp;quot; 未分类的文献（Unfiled） 回收站（Trash）：记录最近删除的文献 我的分组（MY GROUPS）：显示所有定义的组别（包括简单分组、组集、智能分组） 我的标签（MY TAGS）：可以自定义标签，按照标签分类 查找全文（FIND FULL TEXT）：查找本地库里含有全文的文献 在线检索（ONLINE SEARCH）：可以在多个数据库在线检索文献 最下方有搜索框，搜索分组&#xA;文献总览 检索框 分为Simple和Advance两种，和一般的文献检索相同&#xA;下方右侧有快捷工具栏，分别实现手动添加文献、添加好友（可以分享library）、输出library、查找全文、输出一个选中的文献Web引用报告&#xA;此外还有**搜索选项（Search options）**可以实现进阶操作&#xA;文献列表 最上方的文献信息标题栏：右键可添加更多的标题 有回形针标识表示已有附件 文献的重要程度（Rating）：可通过加星来体现文献是否重要 标记笔记（reseach note）：作信息补充 文献显示格式内容：可调整 文献的已读状态 当在文献列表区往下滑动阅读文献时，点击过某篇文献就会显示已读状态，但有时软件默认不会显示，这时需要进行设置，操作步骤如下&#xA;点击&amp;quot;Edit&amp;quot; 选择&amp;quot;Preferences&amp;quot; 在弹出对话框中点击&amp;quot;Read/UnreacT，勾选第一个选框，点击确定 数据库 建立 点击&amp;quot;File&amp;quot; -&amp;gt; &amp;ldquo;new&amp;rdquo;&#xA;选择文件位置，创建enl文件&#xA;此时会产生个人数据库文件，包括MyEndNoteLibrary.Data文件夹和MyEndNoteLibrary.en文件&#xA;MyEndNoteLibrary.Data文件夹中包括三个子文件夹：PDF、rdb、tdb&#xA;PDF子文件夹主要用于存放下载的文献全文，其它两个文件用于存放数据&#xA;打开 点击&amp;quot;File&amp;quot; -&amp;gt; &amp;ldquo;open&amp;rdquo; 选择enl文件即可&#xA;此时，软件窗口的标题栏就会显示当前数据库的名字 之后的操作默认是在该数据库进行的&#xA;添加文献 本地导入 点击&amp;quot;File&amp;quot; -&amp;gt; &amp;ldquo;import&amp;rdquo; 选择&amp;quot;file&amp;quot;或者&amp;quot;folder&amp;quot;&#xA;在弹出的对话框中选择&amp;quot;choose&amp;quot; 来选择文件&#xA;本方法是通过在线检索PDF文件的DOI号从而在线下载文献的各种信息&#xA;中文文献或者没有DOI号的文献需要从相应数据库下载导入EndNote&#xA;在线导入 在Online search 中选择要用的数据库。若没有则点击➕添加数据库&#xA;通过进行检索，找到文献&#xA;检索结果出来后，点击➕，将文献添加进库中&#xA;网站导入 在一些提供科研论文检索的网站中，点击&amp;quot;引用（Cite）&amp;quot; 或者&amp;quot;导出（Export）&amp;quot; 会得到txt文件&#xA;通过本地导入 在&amp;quot;import option&amp;ldquo;中选择Endnote import 再导入txt文件即可</description>
    </item>
    <item>
      <title>Fine tuning</title>
      <link>https://seconsorl.github.io/post/fine-tuning/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/fine-tuning/</guid>
      <description>TIPS https://zhuanlan.zhihu.com/p/673789772&#xA;介绍 微调是指调整大型语言模型（LLM）的参数以适应特定任务的过程。这是通过在与任务相关的数据集上训练模型来完成的。所需的微调量取决于任务的复杂性和数据集的大小。&#xA;在深度学习中，微调是一种重要的技术，用于改进预训练模型的性能。除了微调ChatGPT之外，还有许多其他预训练模型可以进行微调。&#xA;PEFT PEFT（Parameter-Efficient Fine-Tuning）是hugging face开源的一个参数高效微调大模型的工具，里面集成了4种微调大模型的方法，可以通过微调少量参数就达到接近微调全量参数的效果，使得在GPU资源不足的情况下也可以微调大模型。&#xA;微调方法 微调可以分为全微调和重用两个方法：&#xA;全微调（Full Fine-tuning）：全微调是指对整个预训练模型进行微调，包括所有的模型参数。在这种方法中，预训练模型的所有层和参数都会被更新和优化，以适应目标任务的需求。这种微调方法通常适用于任务和预训练模型之间存在较大差异的情况，或者任务需要模型具有高度灵活性和自适应能力的情况。Full Fine-tuning需要较大的计算资源和时间，但可以获得更好的性能。 部分微调（Repurposing）：部分微调是指在微调过程中只更新模型的顶层或少数几层，而保持预训练模型的底层参数不变。这种方法的目的是在保留预训练模型的通用知识的同时，通过微调顶层来适应特定任务。Repurposing通常适用于目标任务与预训练模型之间有一定相似性的情况，或者任务数据集较小的情况。由于只更新少数层，Repurposing相对于Full Fine-tuning需要较少的计算资源和时间，但在某些情况下性能可能会有所降低。 微调预训练模型的方法： 微调所有层：将预训练模型的所有层都参与微调，以适应新的任务。 微调顶层：只微调预训练模型的顶层，以适应新的任务。 冻结底层：将预训练模型的底层固定不变，只对顶层进行微调。 逐层微调：从底层开始，逐层微调预训练模型，直到所有层都被微调。 迁移学习：将预训练模型的知识迁移到新的任务中，以提高模型性能。这种方法通常使用微调顶层或冻结底层的方法。 Fine tuning 经典的Fine tuning方法包括将预训练模型与少量特定任务数据一起继续训练。在这个过程中，预训练模型的权重被更新，以更好地适应任务。所需的Fine-tuning量取决于预训练语料库和任务特定语料库之间的相似性。如果两者相似，可能只需要少量的Fine tuning。如果两者不相似，则可能需要更多的Fine tuning。&#xA;![img](./Fine tuning_img/v2-763deff2ae9439f3c415a39dfbbc7b1d_1440w.jpg)&#xA;Prompt Tuning（P-tuning） Prompt Tuning 是2021年谷歌在论文《The Power of Scale for Parameter-Efficient Prompt Tuning》中提出的微调方法。参数高效性微调方法中实现最简单的方法还是Prompt tuning(也就是我们常说的P-Tuning)，固定模型前馈层参数，仅仅更新部分embedding参数即可实现低成本微调大模型。&#xA;![img](./Fine tuning_img/v2-4407ecbc3bf703aad37c5de9633dede7_1440w.jpg)&#xA;经典的Prompt tuning方式不涉及对底层模型的任何参数更新。相反，它侧重于精心制作可以指导预训练模型生成所需输出的输入提示或模板。主要结构是利用了一个prompt encoder（BiLSTM+MLP），将一些pseudo prompt先encode（离散token）再与input embedding进行拼接，同时利用LSTM进行 Reparamerization 加速训练，并引入少量自然语言提示的锚字符（Anchor，例如Britain）进一步提升效果。然后结合（capital，Britain）生成得到结果，再优化生成的encoder部分。&#xA;![img](./Fine tuning_img/v2-632a4b208c25a1919c459b1b72ba3dfd_1440w.jpg)&#xA;但是P-tuning v1有两个显著缺点：任务不通用和规模不通用。在一些复杂的自然语言理解NLU任务上效果很差，同时预训练模型的参数量不能过小。具体的效果论文中提到以下几点：&#xA;Prompt 长度影响：模型参数达到一定量级时，Prompt 长度为1也能达到不错的效果，Prompt 长度为20就能达到极好效果。 Prompt初始化方式影响：Random Uniform 方式明显弱于其他两种，但是当模型参数达到一定量级，这种差异也不复存在。 预训练的方式：LM Adaptation 的方式效果好，但是当模型达到一定规模，差异又几乎没有了。 微调步数影响：模型参数较小时，步数越多，效果越好。同样随着模型参数达到一定规模，zero shot 也能取得不错效果。 当参数达到100亿规模与全参数微调方式效果无异。 代码示例： from peft import PromptTuningConfig, get_peft_model peft_config = PromptTuningConfig(task_type=&amp;#34;SEQ_CLS&amp;#34;, num_virtual_tokens=10) model = AutoModelForCausalLM.from_pretrained(model_name_or_path, return_dict=True) model = get_peft_model(model, peft_config) Prefix Tuning 2021年论文《Prefix-Tuning: Optimizing Continuous Prompts for Generation》中提出了 Prefix Tuning 方法。与Full-finetuning 更新所有参数的方式不同，该方法是在输入 token 之前构造一段任务相关的 virtual tokens 作为 Prefix，然后训练的时候只更新 Prefix 部分的参数，而 Transformer 中的其他部分参数固定。</description>
    </item>
    <item>
      <title>JSON</title>
      <link>https://seconsorl.github.io/post/json/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/json/</guid>
      <description>介绍 JSON （JavaScript Object Notation） 是一种轻量级的数据交换格式，它易于阅读和编写，并且易于机器解析和生成，在 Web 开发中用于数据的格式化和传输。&#xA;JSON 的数据结构 JSON 由两种数据结构组成：对象和数组。&#xA;对象 对象（object）是由键值对组成的无序集合，键是字符串，值可以是任何类型，包括对象和数组。&#xA;对象由一对花括号{ }包围，键和值之间用冒号:分隔。键值对之间用逗号,分隔。&#xA;举个例子：&#xA;{ &amp;#34;list&amp;#34; : [ { &amp;#34;name&amp;#34;: &amp;#34;Apifox&amp;#34;, &amp;#34;ID&amp;#34;: 2, &amp;#34;city&amp;#34;: &amp;#34;Guangzhou&amp;#34; } ] } 在这个例子中，对象的键是&amp;quot;name&amp;quot;、&amp;quot;ID&amp;quot;和&amp;quot;city&amp;quot;，对应的值是字符串、数字和字符串。&#xA;数组 数组（array）是值（value）的有序集合，每个值可以是任何类型，包括对象和数组。数组由一对方括号[ ]包裹，值之间用逗号,分隔。&#xA;举个例子：&#xA;[ &amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;orange&amp;#34;] 在这个例子中，数组包含三个字符串元素：&amp;quot;apple&amp;quot;、&amp;quot;banana&amp;quot;和&amp;quot;orange&amp;quot;。&#xA;值 值（value）可以是花括号{ }括起来的字符串（String）、数值(Number)、布尔值(true/false)、 null、对象（Object）或者数组（Array），这些结构可以嵌套。&#xA;字符串 JSON 字符串是由双引号&amp;quot; &amp;quot;包围的 Unicode 字符序列，使用反斜杠 \ 转义。&#xA;举个例子：&#xA;{ &amp;#34;name&amp;#34;: &amp;#34;Apifox&amp;#34;, &amp;#34;city&amp;#34;: &amp;#34;Guangzhou&amp;#34; } 在这个例子中，字符串&amp;quot;name&amp;quot;和&amp;quot;city&amp;quot;是由双引号&amp;quot; &amp;quot;包围的。&#xA;数字 JSON 数字可以是整数或浮点数。&#xA;举个例子：&#xA;{ &amp;#34;age&amp;#34;: 30, &amp;#34;weight&amp;#34;: 65.5 } 在这个例子中，数字&amp;quot;30&amp;quot;和&amp;quot;65.5&amp;quot;分别是整数和浮点数，不需要双引号&amp;quot; &amp;quot;包围。&#xA;布尔值 JSON 布尔值只有两个取值：true 和 false。&#xA;举个例子：&#xA;{ &amp;#34;isStudent&amp;#34;: true, &amp;#34;isEmployed&amp;#34;: false } 在这个例子中，布尔值&amp;quot;isStudent&amp;quot;的取值为true，布尔值&amp;quot;isEmployed&amp;quot;的取值为false，不需要双引号&amp;quot; &amp;quot;包围。&#xA;null JSON 的 null 表示一个空值。&#xA;举个例子：&#xA;{ &amp;#34;middleName&amp;#34;: null } 在这个例子中，&amp;quot;middleName&amp;quot;的值为null，不需要双引号&amp;quot; &amp;quot;包围。</description>
    </item>
    <item>
      <title>kali</title>
      <link>https://seconsorl.github.io/post/kali/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/kali/</guid>
      <description>TIPS https://blog.csdn.net/qq_49318132/article/details/145821899&#xA;https://www.cnblogs.com/lsdb/p/6682545.html&#xA;https://www.kaliorg.com/forum.php</description>
    </item>
    <item>
      <title>linux下docker资源限制</title>
      <link>https://seconsorl.github.io/post/linux%E4%B8%8Bdocker%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/linux%E4%B8%8Bdocker%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</guid>
      <description>设置docker容器所能使用的资源上限 启动容器 先启动docker&#xA;查看一下状态，要在运行状态&#xA;查看cgroups tree&#xA;找到docker，可以看到第一个就是我们刚才启动的docker。&#xA;这里你会找到 2 个。一个是在.slice 里面，一个是在 system.slice 里的 containerd.service里。&#xA;查看使用情况 使用 docker stats 可以查看多个容器的使用情况&#xA;docker stats --format &amp;quot;table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}&amp;quot; 可以格式化输出&#xA;在容器中使用 top 命令可以单一容器的使用情况。&#xA;设置CPU上限 访问docker的cpu配置文件目录：&#xA;cd /sys/fs/cgroup/cpu/system.slice/containerd.service&#xD;cd /sys/fs/cgroup/cpu/docker/&amp;lt;容器ID&amp;gt; system.slice system.slice里面有很多，我们进入容器服务的目录，containerd.service&#xA;目录中的cpu.cfs_period_us文件是控制CPU总权数的，而cpu.cfs_quota_us是控制当前容器权数的，里面的内容只有一个数字。&#xA;后者的值相对于前者的百分比即为总容器服务的可使用的CPU上限。&#xA;如果 cpu.cfs_quota_us 为-1时，表示对CPU使用时间没有限制，控制组内的进程可以完全占用CPU资源‌&#xA;这里你可以通过 echo &amp;gt; &amp;lt;file_name&amp;gt; 设置具体值。&#xA;docker docker目录下的 &amp;lt;容器ID&amp;gt;目录下&#xA;这里是设置对于这个容器的cpu使用限制，同上&#xA;其他 此外还有 docker.service&#xA;设置内存上限 接下来设置容器内存使用情况&#xA;cd /sys/fs/cgroup/memory/system.slice/containerd.service&#xD;cd /sys/fs/cgroup/memory/docker/&amp;lt;容器ID&amp;gt; 这里 memory.limit_in_byte 就是设置内存的文件，默认单位是Byte</description>
    </item>
    <item>
      <title>MUSA</title>
      <link>https://seconsorl.github.io/post/musa%E6%91%A9%E5%B0%94%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/musa%E6%91%A9%E5%B0%94%E7%BA%BF%E7%A8%8B/</guid>
      <description></description>
    </item>
    <item>
      <title>pytorch</title>
      <link>https://seconsorl.github.io/post/pytorch%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/pytorch%E5%AD%A6%E4%B9%A0/</guid>
      <description>TIPS 中文文档&#xA;学习顺序&#xA;数据模块 -&amp;gt; 模型模块 -&amp;gt; 损失函数 -&amp;gt; 优化器 -&amp;gt; 迭代训练&#xA;下载和安装&#xA;直接pip install pytorch torch.Storage 一个torch.Storage是一个单一数据类型的连续一维数组。&#xA;每个torch.Tensor都有一个对应的、相同数据类型的存储。&#xA;具体数据类型见下表&#xA;类型 描述 类型 描述 byte()、char()、double()、float()、half()、int()、long()、short() 将此存储转为相应类型 cpu() 如果当前此存储不在CPU上，则返回一个它的CPU副本 pin_memory() 如果此存储当前未被锁定，则将它复制到锁定内存中。 cuda(device=None, async=False) 返回此对象在CUDA内存中的一个副本。 如果此对象已在CUDA内存中且在正确的设备上，那么不会执行复制操作，直接返回原对象。参数：&#xA;device(int) - 目标GPU的id。默认值是当前设备。async (bool) -如果值为True，且源在锁定内存中，则副本相对于宿主是异步的。否则此参数不起效果。 clone()、copy_() 返回此存储的一个副本 tolist() 返回一个包含此存储中元素的列表 type(new_type=None, async=False) 将此对象转为指定类型。如果已经是正确类型，不会执行复制操作，直接返回原对象。 size() 大小 张量（tensor） Torch 自称为神经网络界的Numpy, 因为他能将 torch 产生的 tensor 放在 GPU 中加速运算 (前提是你有合适的 GPU), 就像 Numpy 会把 array 放在 CPU 中加速运算。（numpy array 和 torch tensor 是可以自由地转换的。）&#xA;定义 pytorch中的数据结构——Tensor，Tensor是PyTorch中最基础的概念。&#xA;张量其实是一个多维数组，它是标量、向量、矩阵的高维拓展&#xA;Tensor与Variable&#xA;在Pytorch0.4.0版本之后其实Variable已经并入Tensor，Variable是torch.autograd中的数据类型&#xA;Variable的属性 data: 被包装的Tensor&#xA;grad: data的梯度&#xA;grad_fn: fn表示function的意思，记录创建的创建张量时用到的方法，比如说加法，乘法，这个操作在求导过程需要用到&#xA;Tensor的Function， 是自动求导的关键&#xA;requires_grad: 指示是否需要梯度， 有的不需要梯度&#xA;is_leaf: 指示是否是叶子节点（张量）&#xA;Tensor的属性 Tensor共有8个属性，其中有5个是Variable并入过来的，剩下三个如下：&#xA;dtype: 张量的数据类型， 如torch.FloatTensor, torch.cuda.FloatTensor, 用的最多的一般是float32和int64(torch.long)&#xA;shape: 张量的形状， 如(64, 3, 224, 224)</description>
    </item>
    <item>
      <title>docker</title>
      <link>https://seconsorl.github.io/post/docker/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/docker/</guid>
      <description>TIP 安装DOMJudge&#xA;菜鸟教程&#xA;CSDN&#xA;Docker 官网 docker中文库&#xA;Github Docker 源码&#xA;介绍 Docker，翻译过来就是码头工人&#xA;Docker 是dotCloud公司开源的一个基于LXC（Linux Container）的高级容器引擎，基于Go 语言并遵从 Apache2.0 协议开源。&#xA;Linux Container 容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。LXC主要通过Kernel的namespace实现每个用户实例之间的项目隔离，通过cgroup实现对资源的配额和调度。&#xA;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&#xA;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。不依赖于任何语言、框架或者包装系统&#xA;Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）&#xA;基本原理 Docker 的CS模式 在 Docker Client （Docker 的命令行接口）中来运行 Docker 的各种命令，这些命令会传送给在 Docker 的宿主机上运行的 Docker 守护进程。而 Docker 守护进程是负责实现 Docker 各种功能的。&#xA;Docker 客户端与守护进程的通信方式 Docker 客户端与守护进程，实际上是通过 Socket 进行连接的。&#xA;Docker 提供了三种 Socket 连接的模式:&#xA;Unix 的端口模式&#xA;unix:///var/run/docker.sock&#xA;TCP 协议的 host:port 模式&#xA;tcp://host:port&#xA;fd 的 Socket 模式&#xA;fd://socketfd&#xA;其中，Unix 的端口模式是 Docker 默认的客户端与守护进程的连接方式。我们也可以通过配置进行修改，来修改 Socket 连接方式。&#xA;Docker容器技术与虚拟机的区别 相同点：docker和容器技术和虚拟机技术，都是虚拟化技术。&#xA;不同点：docker有着比虚拟机更少的抽象层。 由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。所以docker效率比虚拟机效率高。达到了秒级启动的地步。&#xA;docker相较于VM的优点：&#xA;1、比VM小、快，Docker容器的尺寸减小相比于整个虚拟机大大简化了分布到云和分发时间的开销。Docker启动一个容器实例时间仅仅需要几秒钟。&#xA;2、Docker是一个开放的平台，构建、发布和运行分布式应用程序。&#xA;3、开发人员不需要关系具体是哪个Linux操作系统&#xA;4、Google、微软（azure）、亚马逊、IBM等都支持docker。&#xA;5、Docker支持Unix/Linux操作系统，也支持Windows和Mac。&#xA;Docker局限性：&#xA;Docker用于应用程序时是最有用的，但并不包含数据。日志、数据库等通常放在Docker容器外。一个容器的镜像通常都很小，不用和存储大量数据，存储可以通过外部挂载等方式使用，比如：NFS、ipsan、MFS等 ，或者docker命令 ，-v映射磁盘分区。</description>
    </item>
    <item>
      <title>git</title>
      <link>https://seconsorl.github.io/post/git/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/git/</guid>
      <description>TIPS 菜鸟教程&#xA;Git 完整命令手册&#xA;可视化教程&#xA;简介 起源 随着代码库体积的倍数增加，Linus 和社区的小伙伴们很难继续通过手工的方式管理内核代码。于是 Linus 考察了好些版本控制系统，最终决定采用 BitKeeper。&#xA;但 BitKeeper 是商业软件，要收费的。所以 Linus 跟开发 BitKeeper 的商业公司（BitMover）谈判，成功地忽悠到了 BitKeeper 的免费使用权。&#xA;到了 2005 年，BitMover 公司发现 Linux 团队中有人试图破解 BitKeeper 的加密协议。所以，BitMover收回了 Linux 社区的免费使用权。&#xA;2005年4月3日：Linus 开始开发 Git 2005年4月6日：Git 项目对外发布 2005年4月7日：Git 实现作为自身的版本控制工具 2005年4月18日：实现多分支合并 2005年6月16日：Linux 内核 2.6.12 发布，Git 已经可以用于维护 Linux 核心源码 2005年7月26日：Linus 功成身退，将 Git 的维护工作交给另一名 Git 的主要贡献者 Junio C Hamano 取代 SVN 很多公司原来都是使用 SVN 进行版本控制管理，但越来越多的公司选择将代码迁移至 Git（最具标志性的就是使用 SVN 做版本控制的 Google Code ）。&#xA;SVN 和 Git 的区别 最核心的区别是：SVN 是集中式的版本控制系统，而 Git 是分布式的。&#xA;1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 **2、Git 把内容按元数据方式存储，而 SVN 是按文件：**所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 **3、Git 分支和 SVN 的分支不同：**分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 **4、Git 没有一个全局的版本号，而 SVN 有：**目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 **5、Git 的内容完整性要优于 SVN：**Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 集中式版本控制系统需要找一个服务器作为大本营，所有的代码都需要提交到服务器上进行统一的管理。当你需要对代码进行改动时，需要先从服务器上下载一份拷贝，修改完成之后，还需要上传回服务器。</description>
    </item>
    <item>
      <title>HTML5</title>
      <link>https://seconsorl.github.io/post/html5/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/html5/</guid>
      <description>TIPS HTML5_菜鸟教程&#xA;W3C标准 结构化标准语言（HTML、XML）&#xA;表现标准语言（CSS）&#xA;行为标准（DOM、ECMAScript）&#xA;行内元素和块元素 块元素：会另起一个行。无论内容多少，该元素会独占一行。 行内元素：内容撑开宽度，左右都是行元素的可以排成一行。 NAME属性 name相同表示同一个组&#xA;nav &amp;lt;nav&amp;gt;标签定义导航链接的部分。&#xA;并不是所有的 HTML 文档都要使用到&amp;lt;nav&amp;gt; 元素。&amp;lt;nav&amp;gt;元素只是作为标注一个导航链接的区域。&#xA;在不同设备上（手机或者PC）可以制定导航链接是否显示，以适应不同屏幕的需求。&#xA;结构 基本结构 DOCTYPE声明 网页头部&amp;lt;head&amp;gt; &amp;lt;/head&amp;gt; 网页主体&amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;!-- &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; 开放标签和闭合标签 --&amp;gt; &amp;lt;!-- &amp;lt;hr/&amp;gt;关闭空元素 --&amp;gt; &amp;lt;!-- HTML注释 --&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!-- DOCTYPE: 告诉网页用什么规范&amp;gt; --&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;!-- head 网页头部 --&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;!-- meta描述性标签，用来做SEO--&amp;gt; &amp;lt;meta name=&amp;#34;Keywords&amp;#34; content=&amp;#34;...&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;...&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;!-- title网页标题 --&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- body 网页主体 --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 结构分析 元素名 描述 header 标题头部区域的内容（用于页面或页面中的一块区域） footer 标记脚部区域的内容（用于整个页面或页面的一块区域） section Web页面中的一块独立区域 article 独立的文章内容 aside 相关内容或应用（常用于侧边栏） nav 导航类辅助内容 基本标签和特殊符号 html里面换行是没用的&#xA;连续的空格符被认为是一个空格&#xA;标签和符号 HTML代码 标题 &amp;lt;h1&amp;gt;一级标签&amp;lt;/h1&amp;gt;&amp;lt;h2&amp;gt;二级标签&amp;lt;/h2&amp;gt;&amp;lt;h3&amp;gt;三级标签&amp;lt;/h3&amp;gt;&amp;lt;h4&amp;gt;四级标签&amp;lt;/h4&amp;gt;&amp;lt;h5&amp;gt;五级标签&amp;lt;/h5&amp;gt;&amp;lt;h6&amp;gt;六级标签&amp;lt;/h6&amp;gt; 段落 &amp;lt;p&amp;gt; 内容 &amp;lt;/p&amp;gt; 换行 &amp;lt;br /&amp;gt; 水平线 &amp;lt;hr /&amp;gt; 字体样式 粗体: &amp;lt;strong&amp;gt; &amp;lt;/strong&amp;gt;斜体: &amp;lt;em&amp;gt; &amp;lt;/em&amp;gt; 空格 &amp;amp;nbsp; 大于&amp;gt; &amp;amp;gt; 小于&amp;lt; &amp;amp;lt; 版权符号© &amp;amp;copy; 注释（多行） &amp;lt;!</description>
    </item>
    <item>
      <title>HuGo</title>
      <link>https://seconsorl.github.io/post/hugo/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/hugo/</guid>
      <description>TIPS 中文文档&#xA;英文文档&#xA;Hugo的使用&#xA;实战&#xA;https://zhuanlan.zhihu.com/p/396669087&#xA;部署到github&#xA;部署到云服务器&#xA;目录解释&#xA;优点 静态文件安全、备份方便&#xA;WordPress（运行在php上的）的缺点：&#xA;备份：不断备份数据库。&#xA;插件：实现功能需要不同插件，不断升级。&#xA;升级：不断升级来确定安全性。&#xA;Markdown文件管理及方便&#xA;纯文本&#xA;格式统一&#xA;Windows下载方便，单文件的&#xA;其他的同类jekyll、HEXO 已知缺点 要确认申请的主机是否支持中文语言（URL） 安装 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件&#xA;首先安装好依赖的工具：&#xA;Git Mercurial Go 1.3+ (Go 1.4+ on Windows) 设置好 GOPATH 环境变量，获取源码并编译：&#xA;$ export GOPATH=$HOME/go $ go get -v github.com/spf13/hugo 源码会下载到 $GOPATH/src 目录，二进制在 $GOPATH/bin/&#xA;如果需要更新所有Hugo的依赖库，增加 -u 参数：&#xA;$ go get -u -v github.com/spf13/hugo 生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：&#xA;$ hugo new site /path/to/site 在 /path/to/site 目录里生成了初始站点，站点目录结构：&#xA;▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml 接下来需要完成以下几步：&#xA;Change the current directory to G:\HuGo\hugo\HZW.&#xA;（切换路径到站点目录下）&#xA;Create or install a theme:&#xA;Create a new theme with the command &amp;ldquo;hugo new theme &amp;rdquo; Install a theme from https://themes.</description>
    </item>
    <item>
      <title>1111</title>
      <link>https://seconsorl.github.io/post/%E6%AF%95%E6%98%87%E7%BC%96%E8%AF%91%E5%99%A8/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E6%AF%95%E6%98%87%E7%BC%96%E8%AF%91%E5%99%A8/</guid>
      <description>+++ hzw=123</description>
    </item>
    <item>
      <title>cURL</title>
      <link>https://seconsorl.github.io/post/curl/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/curl/</guid>
      <description>https://www.ruanyifeng.com/blog/2011/09/curl.html&#xA;https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</description>
    </item>
    <item>
      <title>DevEco</title>
      <link>https://seconsorl.github.io/post/deveco_manual/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/deveco_manual/</guid>
      <description></description>
    </item>
    <item>
      <title>Django</title>
      <link>https://seconsorl.github.io/post/django%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/django%E8%AF%B4%E6%98%8E/</guid>
      <description>创建项目 django-admin startproject &amp;#34;项目名称&amp;#34; //结构如下 $ cd 项目名称/ $ tree . |-- 项目名称 | |-- __init__.py | |-- asgi.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py HelloWorld: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 HelloWorld/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 HelloWorld/asgi.py: 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。 HelloWorld/settings.py: 该 Django 项目的设置/配置。 HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&amp;quot;目录&amp;quot;。 HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 启动服务器 python manage.py runserver 0.0.0.0:8000 --这句话需要在项目文件夹下执行 0.0.0.0 让其它电脑可连接到开发服务器，8000 为端口号。如果不说明，那么端口号默认为 8000。&#xA;在浏览器输入你服务器的 ip（这里我们输入本机 IP 地址： 127.0.0.1:8000） 及端口号，如果正常启动，页面中间是一个小火箭&#xA;可以manage.py里修改配置&#xA;if __name__ == &amp;#39;__main__&amp;#39;: from django.core.management.commands.runserver import Command as Runserver Runserver.default_addr = &amp;#39;127.0.0.1&amp;#39; # 修改默认地址 Runserver.default_port = &amp;#39;8080&amp;#39; # 修改默认端口 main() urls.</description>
    </item>
    <item>
      <title>golang</title>
      <link>https://seconsorl.github.io/post/golang/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/golang/</guid>
      <description>TIPS 菜鸟教程&#xA;谷歌文档&#xA;中文网&#xA;Golang入门教程&#xA;他人博客&#xA;简介 Go 是一个开源的编程语言，它的设计初衷是为了简单、高效。&#xA;Go是由谷歌2007年创建，由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定的开源版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。（Ken Thompson还是B、C语言发明者）&#xA;语言特色&#xA;简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 用途&#xA;Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。&#xA;对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。&#xA;开发团队 Ken Thompson - 83年图灵奖、98年美国国家技术奖、00年去当一次飞行员&#xA;Rob Pike - UTF-8发明人、天文学家、会射箭&#xA;Robert Griesemer - Java hot spot设计者之一、谷歌浏览器的GS引擎&#xA;简史 2007年，开始设计，这是Go语言的最初原型。&#xA;2009年11月，Google将Go语言以开放源代码的方式向全球发布。&#xA;2015年8月，Go1.5版发布，本次更新中移除了最后残余的c代码。&#xA;吉祥物 - 囊地鼠gopher，由Rob Pike的妻子 Renee French绘制的&#xA;安装 下载地址&#xA;https://go.dev/dl/。&#xA;https://golang.google.cn/dl/。&#xA;安装教程&#xA;https://www.runoob.com/go/go-environment.html&#xA;安装完毕后，有安装目录下有多个文件&#xA;api：API存放，使用手册 bin：Go命令，go（编译运行）、gofmt（格式化） 测试SDK环境搭建&#xA;运行go version&#xA;GOROOT和GOPATH GOROOT和GOPATH都是环境变量，其中GOROOT是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为GOPATH设置一个默认目录，并且在Go1.14及之后的版本中启用了Go Module模式之后，不一定非要将代码写到GOPATH目录下，所以也就不需要我们再自己配置GOPATH了，使用默认的即可。&#xA;想要查看你电脑上的GOPATH路径，只需要打开终端输入以下命令并回车：&#xA;go env 在终端输出的内容中找到GOPATH对应的具体路径。&#xA;GOPROXY 非常重要 Go1.14版本之后，都推荐使用go mod模式来管理依赖环境了，也不再强制我们把代码必须写在GOPATH下面的src目录了，你可以在你电脑的任意位置编写go代码。&#xA;默认GoPROXY配置是：GOPROXY=https://proxy.golang.org,direct，由于国内访问不到https://proxy.golang.org，所以我们需要换一个PROXY，这里推荐使用https://goproxy.io或https://goproxy.cn。&#xA;可以执行下面的命令修改GOPROXY：&#xA;go env -w GOPROXY**=**https://goproxy.cn,direct Go项目结构 在进行Go语言开发的时候，我们的代码总是会保存在$GOPATH/src目录下。在工程经过go buiLd、go install或go get等指令后，会将下载的第三方包源代码文件放在$GOPATH/src目录下，产生的二进制可执行文件放在$GOPATH/bin目录下，生成的中间缓存文件会被保存在$GOPATH/pkg下。&#xA;如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin和pkg目录的内容无需版本控制。&#xA;个人开发者 源代码都是存放在GOPATH的目录下，那我们可以按照下图来组织我们的代码。&#xA;流行 Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用顶级域名来作为包名的前缀，这样就不担心项目名冲突的问题了。&#xA;因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。</description>
    </item>
    <item>
      <title>ini</title>
      <link>https://seconsorl.github.io/post/ini/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/ini/</guid>
      <description>ini INI文件的起源和发展 INI文件的概念最早由Microsoft在20世纪80年代提出并使用在早期的Windows操作系统中。INI文件的设计初衷是为了存储应用程序的配置数据。“INI&amp;quot;一词是&amp;quot;Initialization”（初始化）的缩写。&#xA;当时的Windows操作系统并没有统一的配置文件格式，每个应用程序都需要自己实现配置文件的读取和写入。为了解决这个问题，Microsoft引入了INI文件作为一种通用的配置文件格式，以简单的键值对的方式存储配置数据。&#xA;INI文件的设计初衷是为了提供一种轻量级、易于编辑和解析的配置文件格式。之后，INI文件成为了Windows系统中常见的配置文件格式，并被许多应用程序广泛采用。&#xA;虽然INI文件最早由Microsoft引入，并在Windows系统中得到广泛应用，但INI文件的概念和实现方式也被其他操作系统和应用程序所采用和扩展。不同的操作系统和应用程序可能会对INI文件有些许的差异和扩展，但基本的键值对结构和语法规则基本保持一致。&#xA;作用 INI文件（Initialization File）是一种用于存储配置数据的文本文件格式。它通常以简单的键值对（Key-Value）的形式组织数据，用于保存应用程序的各种设置和选项。例如：数据库连接配置、网络设置、界面风格、语言选择等。通过读取和修改INI文件，用户和开发者可以轻松地配置和个性化应用程序，满足特定的需求。&#xA;.ini , .inc之类的文件，一般是放一些常量或数据库链接语句等，再在需要的页面包含进去，和直接命为 asp 是没什么区别的。&#xA;语法 节（section） 节用方括号[ ]括起来，用于区分不同的配置项，例如：[section1]。节名可以是任何字符和数字的组合，但一般建议使用有意义的名称。&#xA;名称单独出现在一行中 名称在方括号 [ 和 ]中 没有明确的 section 结束分隔符 在下一个 section 声明处或文件末尾处结束 部分和属性名称不区分大小写 键值对 （key-value） 键值对是配置项的基本元素，用于存储具体的配置数据。键（Key）和值（Value）之间用等号=或冒号:分隔。例如：Key1=Value1。（单独占一行）&#xA;注释 （Comment） 注释用来添加对配置项的说明，不会被程序读取。在INI文件中，以分号;或井号#开头的行都被视为注释。例如：;我是注释我是注释。&#xA;空行（Blank Line） 空行不包含任何内容，通常用于提高文件的可读性。&#xA;字符串（string） 键和值可以是任何文本，包括字母、数字、标点符号等。字符串可以使用引号（单引号&#39;&#39;或双引号&amp;quot;&amp;quot;）括起来，也可以不括起来。&#xA;字母数字字符加下划线的任意字符，重复直至终止符（通常为行尾、&amp;quot;=&amp;ldquo;或者&amp;rdquo;-&amp;quot;）。&#xA;注意：INI文件不一定都是以 .ini 为文件后缀名。其他常见的后缀名还有：.cfg .conf&#xA;数组（array） array[]=first value array[]=second value ;与下面json的代码相同 &amp;#34;array&amp;#34;: [ &amp;#34;first value&amp;#34;, &amp;#34;second value&amp;#34; ] 嵌套节 在标准的INI文件格式中，并没有直接支持嵌套节的概念。每个节都是独立的，并且没有层次结构。&#xA;然而，一些解析INI文件的库或工具提供了对嵌套节的支持，通过特定的约定或语法扩展来模拟嵌套的结构。这样可以在节内部创建子节或子命名空间，以更好地组织和表示配置数据。&#xA;可以使用点号 . 或大括号 {} 来表示嵌套的节&#xA;[Section1] ;节 Key1=Value1 ;键值对 [Section1.Subsection1] Key2=Value2 [Section1.Subsection2] Key3=Value3 注意：嵌套节的使用可能会依赖于具体的解析器或库，不同的工具对语法的支持和解析方式可能有所不同。因此，在使用嵌套节时，应该遵循相应工具的文档和准则，并确保解析器能够正确解释INI文件中的嵌套节。&#xA;转义字符 转义符 描述 \\ \ (单个反斜杠，转义转义字符) \&#39; 撇号 \&amp;quot; 双引号 \0 空字符 \a 铃声/警报/声音 \b 退格键，某些应用程序的贝尔字符 \t 制表符 \r 回车 \n 换行 ; 分号 \# 数字符号 \= 等号 \: 冒号 \x?</description>
    </item>
    <item>
      <title>JavaScript</title>
      <link>https://seconsorl.github.io/post/javascript/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/javascript/</guid>
      <description>TIPS w3school&#xA;浏览器运行的时候会自动在每行后面加一个;，需要注意不要换行&#xA;JS代码没问题就不会报错；会变成Undefine&#xA;了解前端 JavaScript一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。&#xA;Native 原生JS开发 按照【ECMAScript】的方式开发，简称ES，所有浏览器支持（ES5）。ES6是常用的，当前主流版本：webpack打包成为ES5支持。区别就是增加了新特性。&#xA;TypeScript 微软标准 有些情况下需编译（成JS）才能执行。&#xA;JS框架 jQuery：优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6、7、8；&#xA;Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的点是版本迭代不合理（如：1代-&amp;gt;2代，除了名字，基本就是两个东西&#xA;React：Facebook出品，一赖高性能的JS前端框架；特点是提出了新概念虚拟DOM用于减少真实DOM操作，在内存中模拟DOM操作，有效提升了前端渲染效率；缺点是使用复杂。因为需要额外学习一门JSX语言；&#xA;Vue：一款渐进式JavaScript框架，所渭渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular（模块化）和React（虚拟DOM）的优点；&#xA;Axios：前端通信框架；因为Vue的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能；&#xA;UI框架 Ant-Design：阿里巴巴出品，基于React的UI框架&#xA;ElementUl、iview、ice：饿了么出品，基于Vue的UI框架&#xA;Bootstrap：Twitter推出的一个用于前端开发的开源工具包&#xA;AmazeUl：一款HTML5跨屏前端框架&#xA;JavaScript构建工具 Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript&#xA;WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载&#xA;三端统一 主要目的是实现一套代码三端同意。打包方式有以下两种：&#xA;云打包：HBuild -&amp;gt; HBuildX，DCloud出品；API Cloud&#xA;本地：Cordova（前身是PhoneGap）&#xA;快速入门 引入JS HTML的script标签内写JS代码 &amp;lt;script&amp;gt; alter(&amp;#34;Hello World&amp;#34;); &amp;lt;/script&amp;gt; 在.js文件中写，html中引用即可 &amp;lt;script src=&amp;#34;路径&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; 必须要加闭标签 &amp;lt;script type=&amp;#34;text/javascript &amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!-- 不用显示定义type，默认js--&amp;gt; 基本 ----------严格区分大小写------------ &amp;lt;script&amp;gt; //1、定义变量 var num=1; var name=&amp;#34;huzhiwen&amp;#34;; //2、条件控制 if ( &amp;amp;&amp;amp; || ){} else{} //与java相同 //注释 /* */ &amp;lt;/script&amp;gt; 调试 浏览器 -&amp;gt; console 单行解释执行&#xA;-&amp;gt; Sources 行号可以设置断点，刷新后右侧可以调试执行&#xA;数据类型 变量 不要以数字开头，可以用_、$开头，可以用中文&#xA;number：js不区分小数、整数、科学计数法；NaN（不是一个数字）；INF（无限大）&#xA;字符串：单双引号都可以&#xA;布尔值：true、false；&#xA;逻辑运算：&amp;amp;&amp;amp;、||、！&#xA;比较运算符：==（不是=）类型不一样，但是值一样也会 true 、===（绝对等于）类型一样，值一样才会 true 。&#xA;NaN 与所有数值都不相等（包括自己），只能通过 isNaN(x) 判断x是不是 NaN 浮点数问题：计算机不会算，所以会有精度损失，尽量避免进行运算。&#xA;null 和 undefined ：null 空，undefined 未定义</description>
    </item>
    <item>
      <title>JS</title>
      <link>https://seconsorl.github.io/post/javascript_manual/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/javascript_manual/</guid>
      <description>用法 HTML 中的 Javascript 脚本代码必须位于 &amp;lt;script&amp;gt; 与 &amp;lt;/script&amp;gt; 标签之间。脚本可位于 HTML 的 &amp;lt;body&amp;gt; 或 &amp;lt;head&amp;gt; 部分中，或者同时存在于两个部分中。&#xA;可以在 HTML 文档中放入不限数量的脚本。&#xA;通常的做法是把函数放入 &amp;lt;head&amp;gt; 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。&#xA;外部的 JavaScript 可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。&#xA;如需使用外部文件，请在 &amp;lt;script&amp;gt; 标签的 src 属性中设置该 .js 文件的路径。&#xA;外部js文件不使用 &amp;lt;script&amp;gt;标签，直接写 js 代码。&#xA;在Chrome中查看 1、Console 窗口调试 JavaScript 代码 F12的Console 窗口（控制台）调试 JavaScript代码，在 &amp;gt; 符号后输入我们要执行的代码。&#xA;点击禁止的图标，可以清空 Console 窗口的内容&#xA;2、Chrome snippets 小脚本 在 Sources （源）面板，选择 Snippets （代码段）选项卡可以创建脚本文件&#xA;输出/显示 JavaScript 可以通过不同的方式来输出数据：&#xA;使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 document.write() //写到 HTML 文档 HTML 输出流中使用 document.write，相当于添加在原有html代码中添加一串html代码。&#xA;而如果在文档加载后使用（如使用函数），会覆盖整个文档。&#xA;原因：如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。&#xA;alert()/window.alert() alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。&#xA;括号里面添加数据，使用的时候页面会出现警告框，提示内容即为括号内容。&#xA;查找/修改 HTML 元素 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.</description>
    </item>
    <item>
      <title>Latex</title>
      <link>https://seconsorl.github.io/post/latex/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/latex/</guid>
      <description>一些符号说明 [h]当前位置。 将图形放置在正文文本中给出该图形环境的地方。 如果本页所剩的页面不够，这一参数将不起作用。 [t]顶部。 将图形放置在页面的顶部。 [b]底部。 将图形放置在页面的底部。 [p]浮动页。 将图形放置在一只允许有浮动对象的页面上，比如图形和表格。 加 !是LaTex排版系统忽略“美学”标准，把表格和图片插入到你的代码中，是动的 但是不加!，图和表按顺序放置，所以加了!会使图片随着你的代码移动 h, t, b, p是可以组合使用的，如：&#xA;[ht]表示当前位置的顶部 [hb]表示当前位置的底部 表格 c居中，l左对齐,r右对齐 %长文本情况可以设置列宽度 \begin{tabular}{c|*{3}{c|}p{5cm}} %*{数量}{格式}&#x9;当你有许多列时，可以使用这个，并且是限制重复的有效方法 %p{宽度}、m{宽度} 和 b{宽度}指定文本宽度，其中p顶对齐，m中对齐，b底对齐 %合并行列 \multirow{行的数量}{宽度}{文本} 宽度中填 * 会告诉LaTeX自动管理单元格的大小。 \multicolumn{列的数量}{单元格选项}{位置}{文本} 常用编辑器 TeXMaker: www.xm1math.net/texmaker/ , 全平台，免费&#xA;TeXStudio: texstudio.sourceforge.net/ , 全平台，免费&#xA;WinEdit: www.winedt.com/index.html , 只支持 Windows，收费&#xA;TeXWorks: www.tug.org/texworks/ ，MiKTeX 自带编辑器，免费👍&#xA;TeXShop: pages.uoregon.edu/koch/texsho… ，TeXLive 自带编辑器，免费&#xA;TeXLive&#xA;Windows: tug.org/texlive/win… MacOS: tug.org/mactex/ Linux: www.tug.org/texlive/qui… MiKTeX, 这个资源简单，同一个页面选择不同系统即可&#xA;Windows: miktex.org/download MacOS: miktex.org/download Linux: miktex.org/download Lyx，LyX - The Document Processor，使用简单，开箱即用；所见即所得；丰富的公式支持；免费、跨平台；&#xA;TeXworks，TeXworks，支持代码补全，同时内嵌PDF阅读器，免费。&#xA;常用包和命令 % 页面布局：页面宽度, 页面高度, 页眉高度, 页脚高度，各种边距等等 % \usepackage[a4paper,scale=0.8,hcentering,bindingoffset=8mm]{geometry} % A4纸大小，缩放80%，设置奇数页右边留空多一点 \usepackage{geometry} % 页面布局 宏包 % 定制页眉页脚: \pagestyle, \thispagestyle \usepackage{francyhdr} % 页眉页脚高级定制 宏包 % \usepackage{amsmath} % AMS 数学公式 宏包 \usepackage{amssymb} % AMS 数学符号 宏包 \usepackage{amsfonts} % AMS 数学字体 宏包 \usepackage{amsthm, bm} % 数学 % \usepackage{algorithm} % 算法 \usepackage{algpseudocode} % 伪代码 \usepackage{listings} % 各种语言的代码块 % \usepackage{graphicx} % 插图 宏包 \usepackage{subfigure} % 使用子图像或者子表格 宏包 \usepackage{subcaption} % 图片描述 % \usepackage{courier} % 字体 \usepackage{fontspec} % 字体 % \usepackage{titlesec} % 章节定制 宏包 \usepackage{titletoc} % 目录定制 宏包 \usepackage{cite} % 引用 宏包 \usepackage{natbib} % 参考文件定制 宏包 \usepackage{longtable, diagbox, colortbl, booktabs} % 表格定制 宏包 % \usepackage{list} % 无序列表定制 宏包 \usepackage{enumitem} % 有序列表定制 宏包 % \usepackage[选项列表]{hyperref} % 超链接 宏包 \usepackage{xcolor} % 彩色 宏包 % % ====================== 常用命令 ================= %%%%%%%%%% 标题部分： 标题, 作者, 日期, 脚注等命令 %%%%%%%%%% \title{标题} % 标题 \author{作者} % 作者 \date{日期} % 日期 %\date{} % 留空则不输出日期，不填则自动加上默认日期，所以要不显示日期需要这句命令 \thanks{.</description>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://seconsorl.github.io/post/mysql_manual/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/mysql_manual/</guid>
      <description>启动/关闭服务 1、命令行[管理员身份运行]&#xA;2、net start mysql80 &amp;ndash;启动&#xA;net stop mysql80 &amp;ndash;关闭&#xA;数据类型 数据类型 描述 tinyint 有符号范围为-128至127，无符号允许范围为0到255。 smallint 有符号允许范围为-32768至32767，无符号允许范围为0到65535。 mediumint 有符号允许范围为-8388608至8388607，无符号允许范围为0到16777215。 int 有符号充许范围为-2147483648至2147483647，无符号许范围为0到4294967295。 bigint 有符号允许范围为-9223372036854775808至9223372036854775807，无符号允许范围为0到1844674407370955161615。 float(m,d) 可以定义显示长度(m)和小数(d)，默认为10,2，其中2是小数的数量，10是数字(包括小数)的总数。 double(m，d) 可以定义显示长度(m)和小数(d)的数量，默认为16,4，其中4个是小数的数量。需要8个字节的存储。 decimal(m，d) 定义显示长度(m)和小数(d)的数量是必需的。 bit(m) 它用于将位值存储到表列中。这里，m确定每个值的比特数为1到64。 bool 仅用于true和false条件。它将数值1视为true，0为false。 boolean 它类似于bool。 日期类型 当插入无效值时，使用零值。&#xA;数据类型 最大值 说明 YEAR[(2 | 4)] 年份值为2位数或4位数。 默认值为4位数，存储需要1个字节。 DATE 值范围从&#39;1000-01-01&amp;rsquo;到&#39;9999-12-31&amp;rsquo;。 显示为&amp;quot;yyyy-mm-dd&amp;quot;，存储需要3个字节。 TIME 值范围从&amp;rsquo;-838:59:59&amp;rsquo;到&#39;838:59:59&amp;rsquo;。 显示为&amp;rsquo;hh:mm:ss&amp;rsquo;。存储需要3个字节加上分数秒。 DATETIME 值范围从&#39;1000-01-01 00:00:00&amp;rsquo;到&#39;9999-12-31 23:59:59&amp;rsquo;。 显示为&amp;quot;yyyy-mm-dd hh:mm:ss&amp;quot;。存储需要5个字节加上分数秒。 TIMESTAMP(m) 值范围从&#39;1970-01-01 00:00:01&amp;rsquo;UTC到&#39;2038-01-19 03:14:07&amp;rsquo;TC。 显示为&amp;quot;yyyy-mm-dd hh:mm:ss&amp;quot;。存储需要4个字节加上分数秒。 字符串类型 字符串数据类型用于保持纯文本和二进制数据，例如，文件，图像等。MySQL可以基于正则表达式等的模式匹配来执行字符串值的搜索和比较。&#xA;数据类型 最大值 说明 CHAR(size) 最大255个字符。 这里大小是存储的字符数。固定长度字符串。空间填充到相同的大小字符 VARCHAR(size) 最大255个字符。 此处的大小是要存储的字符数，可变长度字符串。 TINYTEXT(size) 最大255个字符。 此处大小是存储的字符数。 TEXT(size) 最大65,535个字符。 此处大小是存储的字符数。 MEDIUMTEXT(size) 最大16,777,215个字符。 此处大小是存储的字符数。 LONGTEXT(size) 最大4gb或4,294,967,295字符。 此处大小是存储的字符数。 BINARY(size) 最大255个字符。 此处的大小是要存储的二进制字符数。固定长度字符串。空间填充到相同的大小字符。 VARBINARY(size) 最大255个字符。 此处的大小是要存储的字符数。可变长度串。 ENUM 需要1或2个字节，取决于枚举值的数量。枚举最多可具有65,535个值。 它使用数字索引(1,2,3 &amp;hellip;)来表示字符串值。 SET 需要1,2,3,4或8个字节，取决于设置成员的数量。它可以存储最大限度的64个成员。 它可以保存零个或多个，或任何数量的字符串值。必须从表创建期间指定的预定义值列表中选择它们。 常用命令 显示所有数据库：show databases;&#xD;显示创建的数据库：show create database 数据库名称;&#xD;创建一个数据库： create database 数据库名称;&#xD;创建数据库前先判断是否存在：create database if not exists 数据库名称;&#xD;创建数据库并设置字符编码格式：create database 数据库名 character set gbk;&#xD;修改数据库的字符集：alter database 数据库名称 character set 字符集名称(utf8);&#xD;删除一个数据库：drop database 数据库名;&#xD;(drop database if exists 数据库名称; 先判断是否存在数据库,存在再删除删除库)&#xD;切换数据库：use 数据库名称; use databasename; 选择数据库&#xD;查询现在正在使用的数据库：select database();&#xD;单行注释： #…&#xD;多行注释： /*…*/&#xD;查询某个数据库的所有表的名称： show tables;&#xD;查询表结构：desc 表名;&#xD;创建表：create table 表名(列名1 数据类型1 ,列名2，数据类型2…);&#xD;复制表：create table 表名1 like 表名2;&#xD;修改表名：alter table 表名 rename to 新的表名;&#xD;显示表的字符创建信息: show create table 表名;&#xD;drop database name 直接删除数据库，不提醒。&#xD;mysqladmin drop database name 删除数据库前，有提示。&#xD;show tables; 列出数据库中的所有表&#x9;describe tablename; 表的详细描述.</description>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://seconsorl.github.io/post/nginx/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/nginx/</guid>
      <description>反向代理介绍 反向代理（Reverse Proxy）方式是指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。&#xA;举个例子，一个用户访问 http://www.example.com/readme，但是 www.example.com 上并不存在 readme 页面，它是偷偷从另外一台服务器上取回来，然后作为自己的内容返回给用户。但是用户并不知情这个过程。对用户来说，就像是直接从 www.example.com 获取 readme 页面一样。这里所提到的 www.example.com 这个域名对应的服务器就设置了反向代理功能。&#xA;正向代理和反向代理 正向代理和代理服务器&#xA;正向代理即通常所说的代理，用于代表内部网络用户向Internet上的服务器(或称外部服务器，通常为Web服务器)发出连接请求，并接收响应结果，执行该代理功能的服务器称为代理服务器。使用代理服务器访问外部网络时，客户端必须在局域网设置中指明代理服务器的地址以及要代理的服务的端口号。&#xA;反向代理和代理服务器&#xA;反向代理的方向与正向代理相反，指代表外部网络用户向内部服务器发出请求，即接收来自Internet上用户的连接请求，并将这些请求转发给内部网络上的服务器，然后将从内部服务器上得到的响应返回给Internet上请求连接的客户：执行反向代理服务的服务器称为反向代理服务器，反向代理服务器对外部用户表现为一个服务器。&#xA;原理 反向代理服务器，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。&#xA;客户端向反向代理的命名空间 (name-space) 中的内容发送普通请求； 接着反向代理将判断向何处 (原始服务器) 转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 作用 解决网站服务器对外可见的问题、私密性、安全性 路由功能：根据用户请求的URL调度到对应功能的节点处理请求 负载均衡：将用户的请求，通过调度算法挑选一台合适的节点处理请求 动静分离：根据用户请求的URL进行区分，将动态资源调度到应用服务器处理，将静态资源调度到静态资源服务器处理 数据缓存：加速网站的访问速度，减轻web服务器的负担。如果用户请求的内容在缓存中，可以直接在代理服务器中获取，加速用户的访问速度。 应用 反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问，加强安全防护。 反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供 缓冲 服务。 另外，反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。 做 HTTP 反向代理 Nginx Nginx(&amp;ldquo;engine x&amp;rdquo;)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。在高连接并发的情况下，Nginx是Apache服务器不错的替代品。&#xA;其他人的博客：https://blog.csdn.net/qq_40036754/article/details/102463099&#xA;https://cloud.tencent.com/developer/article/2355788&#xA;安装 官方教程&#xA;#直接安装 sudo apt install nginx #确认安装成功并检查Nginx版本 nginx -v #启动服务 sudo systemctl start nginx #（可选）设置Nginx开机自启： sudo systemctl enable nginx 启动后在浏览器登录http://localhost:80查看&#xA;配置 编辑默认配置文件:&#xA;sudo nano /etc/nginx/sites-available/default #或者 sudo vim /usr/local/nginx/conf/nginx.conf #或者可以 sudo nginx -t #查看配置文件的位置 nginx 的组成部分</description>
    </item>
    <item>
      <title>PHP</title>
      <link>https://seconsorl.github.io/post/php/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/php/</guid>
      <description>TIPS 链接 菜鸟教程&#xA;PHP官网和安装 https://www.php.net/&#xA;https://www.php.net/manual/zh/install.php&#xA;PHP 文件的默认文件扩展名是 .php。&#xA;简介 PHP 是什么？ PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。&#xA;PHP（全称：PHP：Hypertext Preprocessor，即&amp;quot;PHP：超文本预处理器&amp;quot;）是一种通用开源脚本语言。 PHP 脚本在服务器上执行。 PHP 可免费下载使用。 PHP 文件是什么？ PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 PHP 文件的默认文件扩展名是 .php。 PHP 能做什么？ PHP 可以生成动态页面内容 PHP 可以创建、打开、读取、写入、关闭服务器上的文件 PHP 可以收集表单数据 PHP 可以发送和接收 cookies PHP 可以添加、删除、修改您的数据库中的数据 PHP 可以限制用户访问您的网站上的一些页面 PHP 可以加密数据 通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。</description>
    </item>
    <item>
      <title>postman</title>
      <link>https://seconsorl.github.io/post/postman/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/postman/</guid>
      <description>TIPS 官网&#xA;学习1 已至6&#xA;学习2&#xA;介绍 Postman是一个接口测试工具，用于测试http协议接口。&#xA;在做接口测试的时候，Postman相当于一个客户端，它可以模拟用户发起的各类HTTP请求，将请求数据发送数据发送至服务端，获取对应的响应结果，从而验证响应中的结果数据是否和预期值相匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线之后的稳定性和安全性。 它主要是用来模拟各种HTTP请求的（如:get/post/delete/put..等等），Postman与浏览器的区别在于有的浏览器不能输出Json格式，而Postman更直观接口返回的结果。&#xA;环境安装 postman可以直接在chrome上安装插件&#xA;本地安装postman 客户端工具，Postman 可作为适用于Mac，Windows（32位/ 64位）和Linux（32位/ 64位）操作系统的本机桌面应用程序使用。&#xA;Postman官网下载地址 https://www.postman.com/downloads/：&#xA;Postman for MAC https://dl.pstmn.io/download/latest/osx Postman for windows 64 https://dl.pstmn.io/download/latest/win64 Postman for windows X86 https://dl.pstmn.io/download/latest/win32 Postman for linux https://dl.pstmn.io/download/latest/linux64 发送GET请求 测试接口（获取今日天气） 详细说明&#xA;请求示例(json)&#xA;请求参数说明&#xA;app 是获取哪天的数据，weather.today是获取今天的，weather.future获取未来五天的&#xA;wedid 是城市气象编号，与中国天气网编号一致，如上海：101020100&#xA;key和sign是身份验证，注册一个可以换成自己的，上例中的10003是公众帐号，&#xA;format是返回格式，支持 json，xml&#xA;除了format不是必须的以外，其他参数都是必须提供的。&#xA;# 作者-上海悠悠 QQ交流群:717225969 # blog地址 https://www.cnblogs.com/yoyoketang/ { &amp;#34;success&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;result&amp;#34;: { &amp;#34;weaid&amp;#34;: &amp;#34;36&amp;#34;, &amp;#34;days&amp;#34;: &amp;#34;2021-05-06&amp;#34;, &amp;#34;week&amp;#34;: &amp;#34;星期四&amp;#34;, &amp;#34;cityno&amp;#34;: &amp;#34;shanghai&amp;#34;, &amp;#34;citynm&amp;#34;: &amp;#34;上海&amp;#34;, &amp;#34;cityid&amp;#34;: &amp;#34;101020100&amp;#34;, &amp;#34;temperature&amp;#34;: &amp;#34;24℃/19℃&amp;#34;, &amp;#34;temperature_curr&amp;#34;: &amp;#34;22℃&amp;#34;, &amp;#34;humidity&amp;#34;: &amp;#34;31%&amp;#34;, &amp;#34;aqi&amp;#34;: &amp;#34;57&amp;#34;, &amp;#34;weather&amp;#34;: &amp;#34;小雨&amp;#34;, &amp;#34;weather_curr&amp;#34;: &amp;#34;多云&amp;#34;, &amp;#34;weather_icon&amp;#34;: &amp;#34;http://api.k780.com/upload/weather/d/1.gif&amp;#34;, &amp;#34;weather_icon1&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;wind&amp;#34;: &amp;#34;东北风&amp;#34;, &amp;#34;winp&amp;#34;: &amp;#34;1级&amp;#34;, &amp;#34;temp_high&amp;#34;: &amp;#34;24&amp;#34;, &amp;#34;temp_low&amp;#34;: &amp;#34;19&amp;#34;, &amp;#34;temp_curr&amp;#34;: &amp;#34;22&amp;#34;, &amp;#34;humi_high&amp;#34;: &amp;#34;0&amp;#34;, &amp;#34;humi_low&amp;#34;: &amp;#34;0&amp;#34;, &amp;#34;weatid&amp;#34;: &amp;#34;2&amp;#34;, &amp;#34;weatid1&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;windid&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;winpid&amp;#34;: &amp;#34;1&amp;#34;, &amp;#34;weather_iconid&amp;#34;: &amp;#34;1&amp;#34; } } Collection下添加 request 请求 点左上角 New -&amp;gt; 添加 Collection</description>
    </item>
    <item>
      <title>QBittorrent和BT、PT</title>
      <link>https://seconsorl.github.io/post/qbittorrent%E5%92%8Cbtpt/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/qbittorrent%E5%92%8Cbtpt/</guid>
      <description>Qbit下载 官网版本：https://www.qbittorrent.org/download.php&#xA;历史版本：https://www.fosshub.com/qBittorrent-old.html&#xA;所有版本：https://sourceforge.net/projects/qbittorrent/files/&#xA;增强版：https://github.com/c0re100/qBittorrent-Enhanced-Edition/releases&#xA;官方版和增强版的区别，官方版使用时会被迅雷吸血，且不能自动订阅Track，但是可以玩PT(private tracker)；增强版则相反。&#xA;P2P 介绍 **点对点技术（peer-to-peer， 简称P2P）**又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上。P2P网络通常用于通过[Ad Hoc](https://baike.baidu.com/item/Ad Hoc/0?fromModule=lemma_inlink)连接来连接节点。这类网络可以用于多种用途，各种文件共享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。&#xA;纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。这种网络设计模型不同于客户端-服务器模型，在客户端-服务器模型中通信通常来往于一个中央服务器。有些网络（如Napster, OpenNAP）的一些功能（比如搜索）使用客户端-服务器（C/S）结构，而使用P2P结构来实现另外一些功能。类似Gnutella或Freenet的网络则使用纯P2P结构来实现全部的任务。&#xA;p2p资源定位方式 p2p网络中进行资源定位是首先要解决问题。一般采用三种方式：&#xA;集中方式索引：每一个节点将自身能够提供共享的内容注册到一个或几个集中式的目录服务器中。查找资源时首先通过服务器定位，然后两个节点之间再直接通讯。例如早期的napster。这类网络实现简单，但往往需要大的目录服务器的支持，并且系统的健壮性不好。&#xA;广播方式：没有任何索引信息，内容提交与内容查找都通过相邻接节点直接广播传递。例如gnutella。一般情况下，采取这种方式的p2p网络对参与节点的带宽要求比较高。&#xA;动态哈希表的方式：上述两种定位方式可以依据不同的p2p应用环境进行选择，但是人们普遍看好dht(distributed hash **table，分散式杂凑表)**方式。基于dht的p2p网络在一定程度上可以直接实现内容的定位。&#xA;一个矛盾的问题是：如果一个节点提供共享的内容表示越复杂，则哈希函数越不好选择；相应的，网络的拓扑结构就越复杂。而如果内容表示简单，则又达不到真正实现依据内容定位的能力。目前大多数dht方式的p2p网络对节点所提供共享内容的表示都很简单，一般仅仅为文件名。&#xA;现有p2p协议分类 napster：世界上第一个大型的p2p应用网络；中央集中式，倒闭了。&#xA;napster，这是当时很火的一种共享服务，主要用于查找mp3，它有一个服务器用于存储mp3文件的链接位置并提供检索，而真正的mp3文件则存放在千千万万的个人电脑上，搜索到的文件通过p2p方式直接在个人电脑间传播共享。这种方式的缺点就是需要一台服务器，在mp3文件版权之争火热的年代，napster很快就成为众矢之的，被众多唱片公司诉讼侵犯版权而被迫关闭。当然服务器一关napster也就不复存在。&#xA;gnutella和gnutella2（gnutella2是对gnutella的改进和扩展）：开源的；第一个真正非中心的无结构p2p网络，文件查询采用洪泛方式。&#xA;gnutella吸取了napster的失败教训，将p2p的理念更推进一步：它不存在中枢目录服务器，所有资料都放在个人电脑上。用户只要安装了该软件，就将自己的电脑立即变成一台能够提供完整目录和文件服务的服务器，并会自动搜寻其它同类服务器，从而联成一台由无数pc组成的超级服务器网络。传统网络的server和client在它的面前被重新定义。&#xA;fasttrack：第一个客户端是kazaa。协议与gnutella类似。02－03年的最大用户网，05年退至第三名。衰退原因是这个网络无法应对众多用户同时使用，而且有版权拥有者pollution的行为，以及间谍软件的问题。imesh也是以fasttrack为协议的。&#xA;edonkey，overnet，kad：人们在利用p2p软件的时候大多只愿“获取”，而不愿“共享”，p2p的发展遇到了意识的发展瓶颈。不过，一头“驴”很快改变了游戏规则，这就是电驴－edonkey，它引入了强制共享机制。&#xA;edeonkey将网络节点分成服务器层和客户层，并且将文件分块以提高下载速度。edonkey网络下最普及的p2p客户端程序是edonkey2000和emule。emule是edonkey的后继，但是更出色，采用了dht来构建底层网络拓扑，目前非常流行的p2p文件共享软件。 overnet设计的目的是取代edonkey，它没有中心服务器，但用户数少于edonkey。 kademlia 协议，在这里叫做kad网络，采用udp方式通信。很类似于overnet，几乎只有edonkey用户使用它。 bittorrent：借助分散式服务器提供共享文件索引的混合式p2p网络，文件分片下载。下载速度高，没有查找功能，种子具有时效性。它将中心目录服务器的稳定性同优化的分布式文件管理结合起来。&#xA;BitTorrent的意思就是pnp下载，也叫变态下载。bt下载是p2p下载，pp下载的扩展。pnp中的两个p都是指网民的个人电脑，在网上抽象为一个点point。n是之1，2，3，……n中的n就是无限的意思。pnp就是说个人电脑和个人电脑通过网络连接，多对多连接的意思。&#xA;bt下载为什么俗称变态下载呢？这是因为这种下载方式和传统的单单依靠网站服务器作为下载源的方式不同，它采用的是人人电脑都是服务器的思想，下载的人越多，共享的人越多，下载的速度也越快。 BitTorrent 下载工具软件可以说是一个最新概念 P2P 的下载工具、它采用了多点对多点的原理，一般简称 BT(BitTorrent) 也就是大家所说的变态下载。该软件相当的特殊，一般我们下载档案或软件，大都由 HTTP 站点或FTP 站台下载，若同时间下载人数多时，基于该服务器频宽的因素，速度会减慢许多，而该软件却不同，恰巧相反，同时间下载的人数越多你下载的速度便越快，因为它采用了多点对多点的传输原理。&#xA;direct connect：一种常用在小的网络和大学内部网络中的协议，适用于小网络环境中，**dc++**是常见客户端。&#xA;ares：类似gnutella网络。&#xA;BT和PT原理 BT下载时，软件会分析.torrent种子文件得到Tracker地址，然后连接Tracker服务器，服务器返回其他下载者的IP，下载者再与这些IP联系进行下载，从而减轻了服务器的负担，BT下载的Tracker是公开的，而Private Tracker 下载(PT下载)的Tracker则是私有的。&#xA;PT下载是一种小范围的BT下载，通过禁用DHT有要求地选择并控制用户数量，这样，在有限的范围内，下载的用户基本上都可以达到自己的宽带上限，Private Tracker 下载(PT下载)下载还通过论坛等方式的约束机制将BT下载的理念现实化，真正让用户做到下载的过程中努力上传。因此，Private Tracker 下载(PT下载)的速度很快，能够让用户带宽得到最大程度的使用。&#xA;我们下载时用得最多的方式可能就是BT下载。BT下载和传统的依靠网站服务器作为下载源的HTTP/FTP下载不同，采用的是P2P点对点下载方式。BT下载的理念是人人都是服务器，下载的同时也进行上传，这样参与进来的人越多，下载的速度也越快。如果下载的人数足够多，往往可以达到网络带宽的峰值。&#xA;PT实现 首先，划分范围最好的方式就是论坛。新会员必须通过前期的会员邀请才可以加入，邀请注册机制有效地控制了下载人数。 其次是通过passkey，登陆论坛后，系统会给该账号用户分配一个固定的passkey，用户下载的种子中，会包含passkey的信息。若没有passkey的认证通过，即便其他用户得到了种子，也不能进行下载。 第三，PT下载软件使用的是可以计算下载上传流量的BT下载软件，例如Azureus、BitTornado、Transmission、uTorrent等。这类软件下载前，首先要检测用户的passkey，通过后再和种子的passkey进行比对，然后才可进行下载。 第四，通过流量统计控制。PT下载的约束机制就是流量统计，必须保证一定的上传量才能下载。如果界定流量，会不会泄露个人信息呢？流量统计实际是通过软件访问Tracker服务器发送自己的passkey和上传下载信息，并通过PT网站的种子跟踪器，最后来判断用户的流量。界定用户流量仅仅是通过uTorrent等软件中的专用PHP程序，所以并不会泄露用户的其它隐私信息。完整的PT下载就是通过passkey+Tracker服务器两种手段实现，两者缺一不可！ QBit使用 Tracker订阅 设置 -&amp;gt; Bittorrent ，拉到最下面。将Tracker的地址放入框中即可。&#xA;增强版可以放一个文本文件，里面包含了Tracker的地址。软件会自动根据这个地址来自动更新订阅&#xA;TrackersList https://trackerslist.com/#/zh&#xA;RSS订阅（自动追番） 视图 -&amp;gt; RSS阅读器&#xA;左侧为订阅列表；右侧为每一个订阅提供的BT下载列表，双击可以下载。&#xA;RSS阅读器有以下功能。&#xA;可以新建RSS订阅，添加追番的源 源的获取：在BT或者PT网站上，找到有一个和RSS图表相同的按钮（可以先搜索想要的番剧，即筛选）。点击它，复制其网址即可。 RSS订阅重命名 设置 启用获取RSS订阅：启用才可以获取BT链接下载&#xA;RSS消息更新间隔：隔一定时间，向服务器拉取RSS订阅消息来更新。&#xA;每个订阅源文章数目最大值：限制订阅源获取的BT链接的下载数量。也是限制一次下载的最大数量&#xA;启用RSS Torrent自动下载：启用后，软件会对右边BT下载列表所有资源进行下载。&#xA;RSS过滤器：没用过&#xA;RSS下载器：&#xA;下载规则：可以设置资源的保存位置和过滤方式（正则表达式 或不使用）&#xA;必须包含|必须不含，输入时空格表示and的意思&#xA;集数过滤器，其中规则可以鼠标点击并悬停查看&#xA;应用规则：在规则定义的最下面可以勾选存在的RSS订阅&#xA;做种 工具 -&amp;gt; 生成torrent&#xA;路径：本地要共享的文件路径 设置：完成后开始做种 一定要勾选上，不然其他人连接不上，因为不选的话就没有第一个BT文件了。先有1才有2 Tracker网址：即别人来连接的媒介，即会把种子中包含Tracker网址，其他人通过Tracker网址来获取共享者的IP来下载。 </description>
    </item>
    <item>
      <title>RAG</title>
      <link>https://seconsorl.github.io/post/rag/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/rag/</guid>
      <description>TIPS https://zhuanlan.zhihu.com/p/28524880040&#xA;一、RAG核心技术架构与组件交互 1. 三阶段核心流程原理 预处理阶段&#xA;文档解析：HTML/PDF解析中的XPath定位与表格抽取技术（如PyPDFLoader对扫描件的OCR补偿） 分块策略：递归字符分割（RecursiveCharacterTextSplitter）与语义分割（SpacyTextSplitter）的对比，滑动窗口重叠率对信息完整性的影响 向量编码：密集编码（BERT/BGE）与稀疏编码（BM25）的联合使用，通过RoBERTa-Large实现768维语义嵌入 检索阶段&#xA;混合检索引擎：向量检索（Faiss的HNSW索引）+ 倒排索引（Elasticsearch）的级联召回，召回率与响应速度的平衡 重排序机制：Cross-Encoder模型（如MiniLM-L12）对Top100结果进行相关性评分，解决语义漂移问题 生成阶段&#xA;上下文注入：动态上下文窗口技术（如LongLoRA适配），支持10k tokens以上长文本注入 注意力融合：检索片段与原始Prompt在Transformer层的交叉注意力权重分配 2. 进阶架构演进 Naive RAG → Advanced RAG&#xA;索引优化：多粒度分块（段落/句子）与多模态索引（图像OCR文本+结构化表格） 检索增强：查询扩展（Query Rewriting）与HyDE（假设性文档嵌入）技术 Agentic RAG架构&#xA;智能体决策：Toolformer框架下的多工具路由（知识库检索 → 计算器 → API调用） 自修正流程：输出结果通过T5模型进行事实性校验与迭代修正 二、关键组件技术实现细节 1. 检索器模块 双塔模型架构：&#xA;查询编码器（Query Encoder）使用ELECTRA-small，文档编码器（Doc Encoder）使用Contriever 负采样策略：Batch Negative Sampling与Hard Negative Mining对效果的影响 近似最近邻（ANN）算法：&#xA;HNSW图索引：构建参数efConstruction=200，搜索参数ef=100时的召回率/时延曲线 IVFPQ量化：256个粗聚类中心 + 8bit子量化器，压缩比达64倍时的精度损失分析 2. 生成器模块 模型选型策略：&#xA;7B级模型：Qwen-7B在RAG任务中通过LoRA微调的显存占用（18GB vs 原生24GB） 长上下文支持：YaRN插值算法在Llama2-13B上的4096→8192 tokens扩展 提示工程优化：&#xA;结构化指令： 检索内容开始&#xA;{检索结果1}&#xA;检索内容结束&#xA;请根据以上信息回答：{用户问题}，若信息不足请明确说明&#xA;幻觉抑制：Self-Check机制强制输出中每项事实标注来源文档ID 3. 评估体系设计 检索质量指标：&#xA;MRR@10（Mean Reciprocal Rank）与Recall@50的工程验收标准&#xA;生成质量指标：&#xA;Factual Score（基于NLI模型的事实一致性评分）与BLEU-4的联合评估&#xA;端到端测试集：&#xA;构建200个对抗性样本（如歧义查询、矛盾文档）的压力测试方法&#xA;三、工程实践中的组件搭配策略 1. 中小规模场景 组件组合：BGE-M3嵌入模型 + FAISS索引 + GPT-3.5-Turbo生成器 性能表现：500GB文档库下平均响应时间1.8s，GPU消耗8GB 2. 企业级部署方案 混合检索架构：&#xA;A用户查询 &amp;ndash;&amp;gt; B{Query类型判断}&#xA;B &amp;ndash;&amp;gt;关键词明确 C Elasticsearch倒排索引&#xA;B &amp;ndash;&amp;gt;语义模糊 D CLIP向量检索</description>
    </item>
    <item>
      <title>RAID</title>
      <link>https://seconsorl.github.io/post/raid/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/raid/</guid>
      <description>转载至CSDN，方便初学者理解&#xA;一、RAID 概述 1988 年美国加州大学伯克利分校的 D. A. Patterson 教授等首次在论文 “A Case of Redundant Array of Inexpensive Disks” 中提出了 RAID 概念 ，即廉价冗余磁盘阵列（ Redundant Array of Inexpensive Disks ）。由于当时大容量磁盘比较昂贵， RAID 的基本思想是将多个容量较小、相对廉价的磁盘进行有机组合，从而以较低的成本获得与昂贵大容量磁盘相当的容量、性能、可靠性。&#xA;随着磁盘成本和价格的不断降低， RAID 可以使用大部分的磁盘， “廉价” 已经毫无意义。因此， RAID 咨询委员会（ RAID Advisory Board, RAB ）决定用 “ 独立 ” 替代 “ 廉价 ” ，于时 RAID 变成了独立磁盘冗余阵列（ Redundant Array of Independent Disks ）。但这仅仅是名称的变化，实质内容没有改变。&#xA;RAID 这种设计思想很快被业界接纳， RAID 技术作为高性能、高可靠的存储技术，已经得到了非常广泛的应用。 RAID 主要利用数据条带、镜像和数据校验技术来获取高性能、可靠性、容错能力和扩展性，根据运用或组合运用这三种技术的策略和架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求。 D. A. Patterson 等的论文中定义了 RAID1 ~ RAID5 原始 RAID 等级， 1988 年以来又扩展了 RAID0 和 RAID6 。&#xA;近年来，存储厂商不断推出诸如 RAID7 、 RAID10/01 、 RAID50 、 RAID53 、 RAID100 等 RAID 等级，但这些并无统一的标准。目前业界公认的标准是 RAID0 ~ RAID5 ，除 RAID2 外的四个等级被定为工业标准，而在实际应用领域中使用最多的 RAID 等级是 RAID0 、 RAID1 、 RAID3 、 RAID5 、 RAID6 和 RAID10。</description>
    </item>
    <item>
      <title>Shell</title>
      <link>https://seconsorl.github.io/post/shell/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/shell/</guid>
      <description>TIPS 在线编辑器&#xA;菜鸟教程&#xA;介绍 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。&#xA;Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。&#xA;Shell 脚本 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。&#xA;业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。&#xA;由于习惯的原因，简洁起见，本文出现的 &amp;ldquo;shell编程&amp;rdquo; 都是指 shell 脚本编程，不是指开发 shell 自身。&#xA;Shell 环境 Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。&#xA;Linux 的 Shell 种类众多，常见的有：&#xA;Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） Bourne Again Shell（Bash），由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。&#xA;Shell调用形式 打开终端时系统自动调用：/etc/profile 或 ~/.bashrc&#xA;/etc/profile 此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，系统的公共环境变量在这里设置开机自启动的程序，一般也在这里设置。&#xA;~/.bashrc 用户自己的home目录中的.bashrc 登录时会自动调用，打开任意终端时也会自动调用这个文件一般设置与个人用户有关的环境变量，如交叉编译器的路径等。&#xA;运行 指定解析器时候，会创建一个子shell解析脚本&#xA;作为可执行程序 将代码保存为 test.sh，并 cd 到相应目录：&#xA;chmod +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 按照文件中#!指定的解析器解析 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.</description>
    </item>
    <item>
      <title>Shor</title>
      <link>https://seconsorl.github.io/post/shor%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/shor%E7%AE%97%E6%B3%95/</guid>
      <description>非平凡因子 </description>
    </item>
    <item>
      <title>tomcat</title>
      <link>https://seconsorl.github.io/post/tomcat/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/tomcat/</guid>
      <description></description>
    </item>
    <item>
      <title>Toml</title>
      <link>https://seconsorl.github.io/post/toml/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/toml/</guid>
      <description>TIPS 中文文档&#xA;介绍 全称：Tom 的（语义）明显、（配置）最小化的语言。（Tom&amp;rsquo;s Obvious, Minimal Language） 作者：Tom Preston-Werner、Pradyun Gedam 等人。&#xA;应用 TOML是在 2013 年发布的配置文件格式，现在有很多新的明星项目都喜欢用它来做配置文件。&#xA;1、有rust语言的包管理工具cargo；&#xA;2、类似于docker的容器工具containerd；&#xA;3、go语言很多项目都喜欢用。比如静态网站生成工具Hugo、数据库InfluxDB、GitLab CI。&#xA;4、python项目也开始接纳。包管理工具 pip、pipenv和Poetry都是用的TOML,[1]现在连官方的metadata管理也开始支持toml。&#xA;宗旨 TOML 旨在成为一个语义明显且易于阅读的最小化配置文件格式。 TOML 被设计成可以无歧义地映射为哈希表。 TOML 应该能很容易地被解析成各种语言中的数据结构。&#xA;规范 TOML 是大小写敏感的。&#xA;TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档。&#xA;空白是指制表符（0x09）或空格（0x20）。&#xA;换行是指 LF（0x0A）或 CRLF（0x0D 0x0A）。&#xA;#号将此行剩下的部分标记为注释&#xA;# 这是一个全行注释 key = &amp;#34;value&amp;#34; # 这是一个行末注释 another = &amp;#34;# 这不是一个注释&amp;#34; 除制表符以外的控制字符（U+0000 至 U+0008，U+000A 至 U+001F，U+007F）不允许出现在注释中。&#xA;数据结构 键值对 TOML 文档最基本的构成区块是键值对。&#xA;键名在等号的左边，值在右边。 键名和键值周围的空白会被忽略。 键、等号和值必须在同一行（不过有些值可以跨多行）。 key=&amp;#34;value&amp;#34; 键名 键名可以是裸露的，引号引起来的，或点分隔的。&#xA;裸键&#xA;裸键只能包含 ASCII 字母，ASCII 数字，下划线和短横线（A-Za-z0-9_-）。&#xA;裸键不能为空&#xA;注意：裸键允许仅由纯 ASCII 数字构成，例如 1234，但总是被解释为字符串。&#xA;引号键&#xA;引号键遵循与基本字符串或字面量字符串相同的规则并允许你使用更为广泛的键名。&#xA;空引号键是允许的（虽然不建议如此）。&#xA;除非明显必要，使用裸键方为最佳实践。&#xA;点分隔键&#xA;点分隔键是一系列通过点相连的裸键或引号键。 这允许了你将相近属性放在一起：&#xA;点分隔符周围的空白会被忽略，不过，最佳实践是不要使用任何不必要的空白。&#xA;#裸键 ba-re_key = &amp;#34;value&amp;#34; 1234 = &amp;#34;value&amp;#34; #引号键 &amp;#34;127.0.0.1&amp;#34; = &amp;#34;value&amp;#34; &amp;#34;ʎǝʞ&amp;#34; = &amp;#34;value&amp;#34; &amp;#39;quoted &amp;#34;value&amp;#34;&amp;#39; = &amp;#34;value&amp;#34; #裸键不能为空，但空引号键是允许的 = &amp;#34;no key name&amp;#34; # 非法 &amp;#34;&amp;#34; = &amp;#34;blank&amp;#34; # 合法但不鼓励 &amp;#39;&amp;#39; = &amp;#39;blank&amp;#39; # 合法但不鼓励 #点分隔键 name = &amp;#34;Orange&amp;#34; physical.</description>
    </item>
    <item>
      <title>TypeScript</title>
      <link>https://seconsorl.github.io/post/typescript_manual/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/typescript_manual/</guid>
      <description>基础语法 变量声明 </description>
    </item>
    <item>
      <title>Typora</title>
      <link>https://seconsorl.github.io/post/typora_manual/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/typora_manual/</guid>
      <description>TIPS 不在代码块内的HTML代码会被自动识别出来 标题 使用 # 可以表示标题，一级标题对应一个 # ，二级标题对应##号，最多至六级标题。在Typora中，# 后要紧接着一个空格才能表示标题，否则就是普通字符。&#xA;在Typora中，也可以使用快捷键Ctrl+1（2，3，4，5，6）表示相对应的标题。Ctrl+0表示段落。标题快捷键信息可在菜单栏中的段落选项下查看。&#xA;字体 用一对星号 * 括住的文本表示斜体文本 也可以用一对下划线 _ 括住文本来表示斜体文本 也可以使用Typora的快捷键Ctrl+I来表示斜体文本。&#xA;用一对**括住的文本表示粗体文本 也可以用一对 __ 括住的文本来表示粗体文本 也可以使用Typora的快捷键Ctrl+B来表示粗体文本。&#xA;用一对 *** 括住的文本表示粗斜体文本 也可以用一对 ___ 括住的文本来表示粗斜体文本&#xA;各种线 分割线 可以使用三个及以上的 + 号或 * 号或 - 来表示一条分割线；（这个是单独成行的） 由三个*号表示的分割线：&#xA;由三个+号表示的分割线：+++(在CSDN中不代表分割线）&#xA;由三个-号表示的分割线：&#xA;删除线 可以使用一对~~**（波浪号）**括住的文本来表示删除文本；在Typora中，也可以使用快捷键、Alt+Shift+5来加删除线。&#xA;下划线 可以使用HTML的标签&amp;lt;u&amp;gt; &amp;lt;/u&amp;gt;表示增加下划线的文本；在Typora中，也可以使用快捷键Ctrl+U来增加下划线&#xA;列表 无序列表 可以使用 *，+ 或 - 标记符号来表示无序列表项，记住要在标记符号后添加一个空格&#xA;有序列表 可以使用数字加上.再加上空格来表示有序列表（后续编号按回车会自动生成）&#xA;子列表 首先使用*、+或-进入列表，然后回车换行，会发现系统自动生成列表第二项，此时按下Tab键，列表第二项变为第一项的子列表。按回车退出当前列表。可以在无序列表中嵌套有序列表。例如&#xA;123 abc 区块 当我们想要引用别人的文章内容时，可以将其放在区块内。&#xA;可以使用&amp;gt;加空格来表示区块。区块的嵌套就是回车后空两格再打&amp;gt;加空格。&#xA;要退出区块，同样使用Enter键即可。例如：&#xA;123&#xA;123&#xA;123&#xA;123&#xA;代码 如果是一行代码，可以使用段内代码块来表示，用一对 `（数字1旁边的符号）括住代码。&#xA;如果是代码段，那么可以使用三个 ` 加Enter/空格+编程语言来表示。&#xA;可以在代码块的右下角选择编程语言。&#xA;# include &amp;lt;stdio.h&amp;gt; void main(){ printf(&amp;#34;Hello world!\n&amp;#34;); } 或者将代码内容的每一行添加至少四个空格或一个制表符Tab即可&#xA;链接 访问网页 链接的使用方式有两种语法&#xA;[链接文字](链接地址) 或 &amp;lt;链接地址&amp;gt;&#xA;例如：&#xA;​ 百度 https://www.baidu.com/&#xA;鼠标移到链接文字，按住Ctrl + 鼠标左键点击访问。&#xA;访问本地文件 链接还可以打开本地文件，使用方式类似，不过链接地址需要使用本地文件的地址，相对地址、绝对地址均可。&#xA;一个小圆点.表示当前目录；两个小圆点..表示上一级目录。&#xA;页内跳转 也可以使用链接来实现页内跳转。语法如下：</description>
    </item>
    <item>
      <title>Ubuntu 24</title>
      <link>https://seconsorl.github.io/post/ubuntu24/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/ubuntu24/</guid>
      <description>安装 清华镜像&#xA;官网&#xA;命令大全&#xA;启动和关闭过程 Linux系统的启动过程可以分为5个阶段：&#xA;内核的引导。 运行 init。 系统初始化。 建立终端 。 用户登录系统。 内核引导 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。&#xA;操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。&#xA;运行init init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。&#xA;init 程序首先是需要读取配置文件 /etc/inittab。&#xA;运行级别&#xA;许多程序需要开机启动。它们在Windows叫做&amp;quot;服务&amp;quot;（service），在Linux就叫做&amp;quot;守护进程&amp;quot;（daemon）。&#xA;init进程的一大任务，就是去运行这些开机启动的程序。&#xA;但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。&#xA;Linux允许为不同的场合，分配不同的开机启动程序，这就叫做&amp;quot;运行级别&amp;quot;（runlevel）。也就是说，启动时根据&amp;quot;运行级别&amp;quot;，确定要运行哪些程序。&#xA;Linux系统有7个运行级别(runlevel)：&#xA;运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登录后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 系统初始化 在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。&#xA;它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。&#xA;l5:5:wait:/etc/rc.d/rc 5 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。&#xA;而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。&#xA;/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。&#xA;而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。&#xA;这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。&#xA;至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&amp;quot;System Services&amp;quot;来自行设定。&#xA;建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。&#xA;init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：&#xA;1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。&#xA;同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。&#xA;用户登录系统 登录方式有三种：（1）命令行登录（2）ssh登录（3）图形界面登录&#xA;Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。&#xA;然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。&#xA;这通常用来系统维护时防止非root用户登录。只有 /etc/securetty 中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。&#xA;/etc/usertty 文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。&#xA;文字模式和图形模式的切换&#xA;Linux预设提供了六个命令窗口终端机让我们来登录。&#xA;默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</description>
    </item>
    <item>
      <title>Unity</title>
      <link>https://seconsorl.github.io/post/unity-for-myfirstuse/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/unity-for-myfirstuse/</guid>
      <description>TIPS 下载&#xA;英文文档&#xA;中文文档&#xA;中文社区&#xA;下载和安装 去官网下载&#xA;安装 直接运行安装包&#xA;会自动下载最新的编辑器和Tuanjie Hub、Tuanjie Hub编辑器（记得在设置里更改位置，防止全都在C盘）&#xA;学生认证 如果还是学生，可以进行学生认证（免费用）&#xA;在unity hub中的setting中manager license里有学生认证或者直接去这里&#xA;进入后选择“大专学生d”，填写信息，提供证明材料（教务处的证明之类的）&#xA;成功后，进入unity hub 官网，登入账号，登入后点击头像，选择下方的settings，在选择“许可证/席位”&#xA;复制序列号，在unity hub的“通过序列号激活”中输入刚才的序列号即可&#xA;实战 </description>
    </item>
    <item>
      <title>XML</title>
      <link>https://seconsorl.github.io/post/xml/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/xml/</guid>
      <description>TIPS 菜鸟教程&#xA;W3C_school&#xA;简介 XML 被设计用来传输和存储数据。&#xA;HTML 被设计用来显示数据。&#xA;XML 指可扩展标记语言（eXtensible Markup Language）。&#xA;可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言，是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。&#xA;XML 指可扩展标记语言（EXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准。 XML 不是对 HTML 的替代 XML 是对 HTML 的补充。&#xA;XML 不会替代 HTML，XML 用于传输数据，而 HTML 用于格式化并显示数据。&#xA;对 XML 最好的描述是：XML 是独立于软件和硬件的信息传输工具。&#xA;XML 语言没有预定义的标签。XML 允许创作者定义自己的标签和自己的文档结构。比如， &amp;lt;to&amp;gt; 和 &amp;lt;from&amp;gt; 标签没有在任何 XML 标准中定义过，这些标签是由 XML 文档的创作者发明的。&#xA;HTML 中使用的标签都是预定义的。HTML 文档只能使用在 HTML 标准中定义过的标签（如 &amp;lt;p&amp;gt;、&amp;lt;h1&amp;gt; 等等）。&#xA;语法 元素 XML文档由元素构成，每个元素包括开始标签、结束标签和元素内容。&#xA;XML 文档形成了一种树结构，它从&amp;quot;根部&amp;quot;开始，然后扩展到&amp;quot;枝叶&amp;quot;。&#xA;XML 文档使用简单的具有自我描述性的语法：&#xA;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;note&amp;gt; &amp;lt;to&amp;gt;Tove&amp;lt;/to&amp;gt; &amp;lt;from&amp;gt;Jani&amp;lt;/from&amp;gt; &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt; &amp;lt;body&amp;gt;Don&amp;#39;t forget me this weekend!&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt; 第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8）。&#xA;下一行描述文档的根元素（像在说：&amp;ldquo;本文档是一个便签&amp;rdquo;）：&#xA;&amp;lt;note&amp;gt; 接下来 4 行描述根的 4 个子元素（to， from， heading 以及 body）：</description>
    </item>
    <item>
      <title>云原生</title>
      <link>https://seconsorl.github.io/post/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E4%BA%91%E5%8E%9F%E7%94%9F/</guid>
      <description></description>
    </item>
    <item>
      <title>优化器</title>
      <link>https://seconsorl.github.io/post/%E4%BC%98%E5%8C%96%E5%99%A8/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E4%BC%98%E5%8C%96%E5%99%A8/</guid>
      <description>主要优化器 SGD SGD全称Stochastic Gradient Descent，随机梯度下降，1847年提出。每次选择一个mini-batch，而不是全部样本，使用梯度下降来更新模型参数。它解决了随机小批量样本的问题，但仍然有自适应学习率、容易卡在梯度较小点等问题。&#xA;我们要把最小化或最大化的函数称为目标函数或准则。当我们对其进行最小化时，我们也把它称为损失函数或误差函数。&#xA;假设损失函数为$J(\theta)=\frac{1}{2}\sum_{i=1}^m(h_{\theta}(x)-y)^2$，其中$h_{\theta}(x)=\theta_0+\theta_1 x_1++\theta_2 x_2+\dots++\theta_n x_n$，然后我们要使它最小化。&#xA;梯度下降：梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，因此我们在做梯度下降的时候，应该是沿着梯度的反方向进行权重的更新，可以有效的找到全局的最优解。这个参数的更新过程可以描述为： $$ \theta_j:=\theta_j-\alpha \frac{\partial J(\theta)}{\partial \theta_j} \ \frac{\partial J(\theta)}{\partial \theta_j}=\frac{\partial }{\partial \theta_j}\frac{1}{2}(h_\theta(x)-y)^2 \ =2 \cdot \frac{1}{2}(h_\theta(x)-y) \cdot \frac{\partial}{\partial \theta_j}(h_\theta(x)-y) \ =(h_\theta(x)-y) \cdot \frac{\partial}{\partial \theta_j}(\sum_{i=0}^n \theta_i x_i-y) \ =(h_\theta(x)-y)x_j $$&#xA;SGD既可以用于分类计算，也可以用于回归计算。&#xA;SGD算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量及其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。（重点：每次迭代使用一组样本）&#xA;这里的随机是指每次迭代过程中，样本都要被随机打乱，打乱是有效减小样本之间造成的参数更新抵消问题。&#xA;==为什么引入SGD?==&#xA;深度神经网络通常有大量的参数需要学习，因此优化算法的效率和精度非常重要。传统的梯度下降算法需要计算全部样本的梯度，非常耗时，并且容易受到噪声的影响。随机梯度下降算法则可以使用一小部分样本来计算梯度，从而大大提高了训练速度和鲁棒性。此外，SGD还可以避免陷入布局最小值，使得训练结果更加准确。&#xA;==步长比梯度下降法小==&#xA;权值的更新不再通过遍历全部的数据集，而是选择其中的一个样本即可。一般来说其步长的选择比梯度下降法的步长要小一点，因为梯度下降法使用的是准确梯度，所以它可以朝着全局最优解（当问题为凸问题时）较大幅度的迭代下去，但是随机梯度法不行，因为它使用的是近似梯度，或者对于全局来说有时候它走的也许根本不是梯度下降的方法，故而它走的比较缓，同样这样带来的好处就是相比于梯度下降法，它不是那么容易陷入到局部最优解中去。&#xA;更新公式为： $$ &amp;amp;\quad for \ i=1 \ to \ m \ do \ &amp;amp;\qquad \theta_j := \theta_j + \alpha (y^{(i)}-h_\theta (x_j^{(i)}))x_j^{(i)} \ \ \text{(for every j)} \ $$&#xA;分类 随机梯度下降算法通常还有三种不同的应用方式，它们分别是SGD，Batch-SGD，Mini-SGD&#xA;SGD是最基本的随机梯度下降，它是指每次参数更新只使用一个样本，这样可能导致更新较慢。&#xA;Batch-SGD是批随机梯度下降，它是指每次参数更新使用所有样本，即把所有样本都代入计算一遍，然后取它们的参数更新均值，来对参数进行一次性更新，这种更新方式较为粗糙；&#xA;Mini-Batch-SGD是小批量随机梯度下降，它是指每次参数更新使用一小批样本，这批样本的数量通常可以采用trial-and-error的方法来确定，这种方法被证明可以有效加快训练速度。&#xA;优点：&#xA;（1）每一轮参数的更新速度加快。&#xA;缺点：&#xA;（1）准确率下降。由于即使在目标函数为强凸函数的情况下，SGD仍旧无法做到线性收敛。&#xA;（2）可能会收敛到局部最优，由于单个样本并不能代表全部样本的趋势。&#xA;（3）不易于并行实现。&#xA;SGDM SGDM即为SGD with momentum，它加入了动量机制，1986年提出。 $$ v^1=\lambda v^0 - \eta\nabla L(\theta^0) \ \theta^1=\theta^0+v^1 $$ 当前动量V由上一次迭代动量，和当前梯度决定。&#xA;SGDM相比于SGD的差别就在于，参数更新时，不仅仅减去了当前迭代的梯度，还减去了前t-1迭代的梯度的加权和。由此可见，SGDM中，当前迭代的梯度，和之前迭代的累积梯度，都会影响参数更新。</description>
    </item>
    <item>
      <title>偏差-方差窘境</title>
      <link>https://seconsorl.github.io/post/%E5%81%8F%E5%B7%AE-%E6%96%B9%E5%B7%AE%E7%AA%98%E5%A2%83/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E5%81%8F%E5%B7%AE-%E6%96%B9%E5%B7%AE%E7%AA%98%E5%A2%83/</guid>
      <description>Bias - Variance Dilemma(偏差-方差窘境)&#xA;Motivation（动机） 在早期的研究中，人们直观的认为在前提假设（有限的样本空间即抽样所得样本分布，即样本假设空间有限情况）下提高分类器概率估计的准确率即可提高其预测的准确率&#xA;对于有限假设空间，其实泛化误差上界与训练误差，即训练误差越小，泛化误差上界也越小。因此，在某种程度上可以认为训练误差越小，模型泛化误差（上界）越小。&#xA;样本空间无限时，泛化误差上界只与样例数目有关，而于数据分布和样例集无关&#xA;然而，真实情况却是当分类器在拥有较高的概率估计准率情况下，其对新样本的预测性能并没有较大的提高甚至会有所下降。相反一些经典的分类器如朴素贝叶斯、最近邻方法虽然其在高维的数据下并没有较高的概率估计准确率但是其对新样本的预测却能获得不错的结果（朴素贝叶斯早期在文本的预测中如垃圾邮件的分类能有不错的效果，但是有关其为何能在这种大胆的假设下（各因素相互独立，利用独立概率分布代替联合概率分布）取得好的分类效果现在仍不十分明确。&#xA;一种解释是文本的上下文并没有太大的关联，另一种解释是文本中存在“正负相抵”的影响，如情感等）。甚至有时通过“简化”预测的流程（也就是正则化、剪枝、Dropout等操作）也可以提高分类器也测的准确率。对于这种现象学者们进行了一系列的研究，认为有必要提出一种新的不同的指标去观察分类器的性能。&#xA;Bias-Variance decomposition 机器学习中预测是一个十分常见且重要的问题。即我们如何利用给定的一些数据的属性（attributes），即 inputs $X=(x_1,x_2,\dots,x_n)$ 和其对应的输出（outputs）$Y$，从中学习可靠的规则（有监督学习）去预测当新的inputs出现时其对应的outputs（$y$）是多少。&#xA;而针对不同的outputs数据类型，该问题又可以分为分类问题（ $y \in y_1,y_2,\dots,y_n $）和回归问题（$y \in R^1$）。对于分类问题我们一般是根据其预测每一类别（$y_i$）的概率来确定最后的结果（概率最大类别即为输出）。这里我们以二分类问题进行说明&#xA;多分类问题可以转化为多个二分类器进行求解&#xA;记分类器的输入为$X$，$𝑋={𝑥1,𝑥2,&amp;hellip;,𝑥𝑛}$，其输出 𝑦\arrow0,1 一般通过概率确定，即： $$ P(y=1 \mid X)=1−P(y=0 \mid X)=f(X) \tag{1} $$ 式（1）即为分类器的映射函数。此时我们希望寻求一个最优的（理想的）$f(x)$，使得其对于输入$X$的输出 𝑦^(𝑋)∈0,1 分类误差 𝑟(𝑋) 最小（一般用期望或平均损失函数衡量）。</description>
    </item>
    <item>
      <title>压力测试</title>
      <link>https://seconsorl.github.io/post/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</guid>
      <description>介绍 压力测试（Stress Testing）是一种评估系统在极端条件下性能的技术。其目的是确定系统在过载情况下的稳定性和可靠性，识别潜在的瓶颈和弱点。压力测试通常应用于软件、硬件、网络以及其他需要确保高可靠性的系统中。&#xA;压力测试的主要目标 确定系统的最大负载能力：了解系统在超出正常操作条件时能够处理的最大负载。 识别系统的瓶颈：找出系统性能下降或故障的原因，例如CPU、内存、磁盘I/O或网络带宽的限制。 验证系统的稳定性：确保系统在长时间的高负载下仍能保持正常运行，而不会崩溃或出现重大错误。 测试系统的恢复能力：观察系统在压力解除后能否迅速恢复正常运行。 类型 负载测试（Load Testing）：模拟大量用户或操作请求，逐步增加负载，直到系统达到性能极限。 耐久测试（Endurance Testing）：在较长时间内持续施加高负载，测试系统在长时间运行下的稳定性。 尖峰测试（Spike Testing）：突然增加系统负载，观察系统能否迅速适应并处理这种突发负载。 灾难恢复测试（Disaster Recovery Testing）：模拟灾难性事件，测试系统的恢复能力和应急响应能力。 步骤 确定测试目标：明确测试的具体目标和预期结果。 选择测试工具：选择合适的压力测试工具，如Apache JMeter、LoadRunner、Gatling等。 设计测试方案：规划测试的具体步骤，包括负载模型、测试数据、测试场景等。 执行测试：按照测试方案实施测试，逐步增加负载并监控系统性能。 分析测试结果：收集和分析测试数据，找出系统的瓶颈和问题。 优化系统：根据测试结果，对系统进行优化和调整，提高其性能和稳定性。 重新测试：再次进行压力测试，验证优化后的系统能否满足预期的性能要求。 压力测试工具 一些常用的压力测试工具包括：&#xA;Apache JMeter：开源的负载测试工具，支持多种协议（HTTP、HTTPS、FTP等），适用于Web应用的压力测试。 LoadRunner：商业负载测试工具，功能强大，支持广泛的协议和应用。 Gatling：高性能的负载测试工具，基于Scala开发，适用于大规模并发测试。 Siege：轻量级的HTTP负载测试工具，适用于快速测试Web服务器的性能。 通过定期进行压力测试，组织可以确保其系统在实际使用中能够承受预期的高负载，保持高性能和高可靠性，从而提升用户体验和业务连续性。&#xA;Load Impact（K6） Load Impact（现在更名为k6）有提供免费的试用项，对于匿名用户提供25用户三分钟在线模拟，如果是试用用户则可以获得50用户15分钟在线的模拟测试，Load Impact会记录下每一个模拟测试用户的在线情况。&#xA;官网&#xA;学习使用&#xA;步骤 创建项目&#xA;创建新测试&#xA;开始构造&#xA;开始录制（它会记录你在浏览器的使用记录）&#xA;建议先打开一个空的标签页，然后开始录制；&#xA;安装插件K6（如果是第一次使用的话），这个是chrome插件&#xA;录制脚本的网页地址：输入你要录制脚本的网页地址，然后开始录制&#xA;录制操作：确认开始，就会跳转到你要之前输入的录制脚本的地址，然后你在你项目的地址进行操作你要录制的地方，就会录制你要录制的地址的接口、操作、文件、文档、图片资源等。&#xA;录制完成：停止录制，取消按钮 就是停止录制（停止录制后会跳转回来）&#xA;内容筛选：调整你需要留下的压测内容就勾选保存下来，不需要的就不勾选&#xA;设置负载地区：一般默认即可&#xA;设置模拟用户的数量，时间&#xA;设置资源（CPU，内存，响应时间，请求率等）&#xA;设置选项：设置启动时的模拟用户量，结束时的模拟用户量，中间时间的模拟用户量，时长之类等的设置。&#xA;请求的内容删除与修改：请求的内容，可以查看到请求的内容，或者在里面修改，删除之类的&#xA;执行性能测试&#xA;查看测试结果：跑完之后，在创建的项目里面可以看到测试的记录&#xA;导出，保存，分析：右上角 $\vdots$ 出有选项可以导出数据&#xA;接下来可以直接在里面查看压力性能测试的结果，或者导出保存发给其他人进行性能结果分析，然后根据他的响应时间，CPU,内存，等进行分析优化。&#xA;Apache JMeter Apache JMeter 是开源软件，是一个纯 Java 应用程序，旨在加载测试功能行为和测量性能 。它最初是为测试 Web 应用程序而设计的，但后来扩展到其他测试功能&#xA;功能 能够加载和性能测试许多不同的应用程序/服务器/协议类型： Web - HTTP, HTTPS (Java，NodeJS，PHP，ASP.NET， …) SOAP/REST 网络服务 文件传输协议 通过 JDBC 数据库 LDAP 通过 JMS 的面向消息的中间件 (MOM) 邮件 - SMTP(S)、POP3(S) 和 IMAP(S) 本机命令或 shell 脚本 TCP Java对象 全功能测试 IDE，允许快速测试计划记录（从浏览器或本机应用程序）、构建和调试。 CLI 模式（命令行模式（以前称为非 GUI）/headless 模式）从任何 Java 兼容操作系统（Linux、Windows、Mac OSX 等）进行负载测试 一个完整且准备好呈现的动态 HTML 报告 通过从最流行的响应格式HTML、JSON、 XML或任何文本格式 中提取数据的能力轻松关联 完全的可移植性和100% 的 Java 纯度。 完整的多线程框架允许多个线程并发采样和不同线程组同时采样不同的函数。 测试结果的缓存和离线分析/回放。 高度可扩展的核心： 可插拔采样器允许无限的测试能力。 脚本采样器（JSR223 兼容语言，如Groovy和 BeanShell） 可以使用可插入计时器 选择多个负载统计信息。 数据分析和可视化插件允许很大的可扩展性和个性化。 函数可用于为测试提供动态输入或提供数据操作。 通过适用于 Maven、Gradle 和 Jenkins 的第 3 方开源库轻松持续集成 主要的配置元件 测试计划：是使用 JMeter 进行测试的起点，它是其它 JMeter测试元件的容器 线程组：代表一定数量的用户，它可以用来模拟用户并发发送请求。实际的请求内容在Sampler中定义，它被线程组包含 配置元件：维护Sampler需要的配置信息，并根据实际的需要修改请求的内容 前置处理器：负责在请求之前工作，常用来修改请求的设置 后置处理器：负责在请求之后工作，常用获取返回的值 下载 官网 安装需要Java 8+（jdk8以上）</description>
    </item>
    <item>
      <title>批处理</title>
      <link>https://seconsorl.github.io/post/%E6%89%B9%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E6%89%B9%E5%A4%84%E7%90%86/</guid>
      <description>介绍 批处理 批处理(Batch)，也称为批处理脚本。顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，也称作宏。在计算机系统还是DOS（磁盘操作系统是一种早期的命令行操作系统）时期时被大量使用。它应用于DOS和Windows系统中，由DOS或者Windows系统内嵌的命令解释器（通常是COMMAND. COM或者CMD.EXE）解释运行。批处理文件的扩展名为bat 、cmd。比较常见的批处理包含两类：DOS批处理和PS批处理。&#xA;PS批处理是基于微软的PowerShell的，用来批量处理一些任务的脚本；而DOS批处理则是基于DOS命令的，用来自动地批量地执行DOS命令以实现特定操作的脚本。&#xA;更复杂的情况，需要使用if、for、goto等命令控制程式的运行过程，如同C、Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程式是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。&#xA;批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。&#xA;有些人认为批处理语言的含义要比上面的描述更广泛，还包括许多软件自带的批处理语言，如 Microsoft Office、Visual Studio、Adobe Photoshop所内置的批处理语言的功能，用户可通过它们让相应的软件执行自动化操作（例如调整某个资料夹所有 PSD 图档的解析度）。 而这类批处理语言也大多提供把一系列操作录制为批处理文件的功能，这样用户不必写程式就能得到批处理程序。&#xA;在Windows NT以后的平台中，还加入了以.cmd为扩展名的批处理文件，其性能比.bat文件更加优越&#xA;运行流程：系统在解释运行批处理程序时，首先扫描整个批处理程序，然后从第一行代码开始向下逐句执行所有的命令，直至程序结尾或遇见exit命令或出错意外退出。&#xA;Windows中的BAT C:/盘根目录下的AUTOEXEC.BAT批处理文件是自动运行批处理文件，每次系统启动时会自动运行该文件，即开机自启动你可以将系统每次启动时都要运行的命令放入该文件中，例如设置搜索路径，调入鼠标驱动和磁盘缓存，设置系统环境变量等。&#xA;BAT 变量 类型&#xA;批处理中的变量可以储存各种各样的数据。&#xA;不过用来计算时，会发现变量类型转为了int，数值的极端范围为[-2147483648，2147483647]。&#xA;如果不拿来计算的话，数万位也是可以的&#xA;命名&#xA;批处理的变量命名没有什么限制，数字 字母 甚至汉字都可以变成变量名&#xA;扩展&#xA;扩展，可以理解为显示出这个的值。如果想要使用这个变量的值一般情况下都要扩展。扩展用%&amp;lt;var&amp;gt;%，用%包围变量&#xA;参数&#xA;参数在批处理的表达是%0、%1、%2 、&amp;hellip;、%9，以及全部参数%*（%*不会包括%0）&#xA;%0的初始量是批处理本身路径；一般只能取前九个参数，除非使用%*&#xA;shift命令允许你获取后面的参数，其格式为shift [/n]。shift 会使%0变成%1，%1变成%2，……，%9变成原来的第10个参数；shift /1会从%1开始替换，保留原%0&#xA;~的用法：%~1：当参数以引号开头时，%~1会自动将引号删除。&#xA;特殊变量&#xA;%CD% - 扩展到当前目录字符串。&#xA;%DATE% - 用跟 DATE 命令同样的格式扩展到当前日期。&#xA;%TIME% - 用跟 TIME 命令同样的格式扩展到当前时间。&#xA;%RANDOM% - 扩展到 0 和 32767 之间的任意十进制数字。&#xA;%ERRORLEVEL% - 扩展到当前 ERRORLEVEL 数值。&#xA;%CMDEXTVERSION% - 扩展到当前命令处理器扩展版本号。&#xA;%CMDCMDLINE% - 扩展到调用命令处理器的原始命令行。&#xA;%HIGHESTNUMANODENUMBER% - 扩展到此计算机上的最高 NUMA 节点号。&#xA;%~dp0 - 代表的是脚本文件在磁盘的位置&#xA;%~dpI - 第I个文件路径参数的完整父级路径&#xA;%~nxI - 第I个文件路径参数的文件名（包括扩展名）&#xA;%~nI - 第I个文件路径参数的文件名（不包括扩展名）&#xA;命令 ECHO：显示信息，或将命令回显打开或关上。&#xA;ECHO [ON | OFF]：echo on表示打开回显，echo off表示关闭回显&#xA;要显示当前回显设置，键入不带参数的 ECHO。</description>
    </item>
    <item>
      <title>数字信号处理</title>
      <link>https://seconsorl.github.io/post/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</guid>
      <description>数字信号处理 </description>
    </item>
    <item>
      <title>量子密码</title>
      <link>https://seconsorl.github.io/post/%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/</link>
      <pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/</guid>
      <description>TIPS 量子密码技术原理及应用前景初探&#xA;传统密码技术局限 对于对称密码体制，难以安全分发密钥。 对于非对称密码体制，未来一旦算能取得突破（比如通用量子计算机问世），求解数论经典问题将变得轻而易举，届时信息安全将受到全面挑战。 在非对称密码体制下，还有可能遭受中间人攻击。 量子力学 量子 黑体辐射：催生了“量子论”，普朗克的划时代意义的论文《正常光谱能量分布律理论》，得到的重要结论：能量是由确定数目的、彼此相等的、有限的能量包构成。 一个物理量如果存在最小的不可分割的基本单位，则这个物理量是量子化的，并把最小单位称为量子。 “量子化”指其物理量的数值是离散的，而不是连续的任意取值。光子就是一种量子，并且是量子密码学中常使用的量子。 基本特性 量子态的叠加（superposition）：对于量子（如光子、电子等），无法同时测量它的位置和速度，因此量子态是叠加的，量子可以同时具备多种量子态。 干涉（interference）： 纠缠（entanglement）：两个相互纠缠的量子，无论相隔多远，改变其中一个量子的状态时，另一个量子会在瞬间发生状态变化。 不可克隆（nonclonability）：不可复制量子态；或者复制后将破坏原来的量子态。 光子偏振特性 光子在传播过程中，会沿着与传播方向垂直的方向振动。每个光子的振动方向各不相同：有的左右振动，有的上下振动，有些光子的振动方向，则介于垂直方向和水平方向之间。&#xA;在发送光子时，可用特定方向的滤光偏振片去“规定”或“校正”光子的振动方向。在接收光子时，可用特定方向的滤光偏振片让光子通过或不通过：垂直或水平方向振动的光子可以通过直线型滤光片、在遇到斜角型滤光片时，通过或不通过的可能性各为50%（状态为0或1）；45度或135度斜角方向振动的光子可以通过斜角型滤光片、在遇到直线型滤光片时，通过或不通过的可能性各为50%（状态为0或1）。&#xA;量子计算机的优势和弱点 优势&#xA;大数N的因子分解问题是一个NP难题，当N很大时常规计算机无能为力。[[Shor量子算法]]可将此问题变为P问题，这是量子计算机的优势。 除了大数因子分解Shor量子算法外，著名的算法还有[[Grover量子搜索算法]]。 对于量子系统的计算，如果使用常规计算机，其时间复杂度和空间复杂度都很不可观，有些问题在常规计算机上不能计算，量子计算机则可以有效的模拟或计算。量子态具有不可克隆性，而且量子叠加态在测量时出现坍缩，如果将这些特性用于通信，则可完全避免窃听。所以，量子通信技术非常适合于保密通信。 缺点&#xA;由于量子计算机原则上是专用的，应用范围有一定的限制，因此量子计算机不能代替传统的通用计算机。 大数因子分解问题Shor量子算法能将NP问题变为P问题，但不存在能够将NP问题变为P问题的通用算法，比如对于旅行商问题； 如果量子算法使时间复杂度为多项式，则所需功率按指数增长，这是不现实的； 在计算机解题过程中，数据的读出和复制是经常要执行的操作，这些操作在常规计算机中很容易实现，而在量子计算机中，由于量子态的叠加具有坍缩和量子态的不可克隆，实现这些操作很麻烦。 量子密码技术原理 信息安全的根本，归结到如何确保密钥本身的安全。&#xA;密钥分发 信息论创始人香农，总结提出了“无条件安全”的条件：&#xA;密钥真随机且只是用一次； 与明文等长且按位进行二进制异或操作； 只要每次加密时使用一次性随机密钥（一次一密），而且保证密钥不泄露，则加密结果就是安全可靠的。&#xA;光的偏振&#xA;因为光子有两个偏振方向，而且相互垂直。 所以，单光子源每次生成的单个光子&#xA;偏振方向测量&#xA;我们可以简单选取”水平垂直“或”对角“的测量方式（称为测量基），对单光子源产生的单光子进行测量&#xA;对量子编码&#xA;当测量基和光子偏振方向一致，就可以得出结果（要么是1，要么是0）&#xA;量子密钥分发交换原理 利用量子力学原理以及光子偏振特性，可以在信息发送者张三和信息接收者李四之间安全可靠地产生和交换一次性密钥，再用此密钥进行信息加密，理论上就可保证加密结果的安全可靠。&#xA;考虑到通信双方如果都要拥有光子制备和发射设备，成本会非常昂贵，若将光子制备分发处理统一交给通信卫星负责，成本将会大幅下降。关于星地之间如何进行密钥分发处理，暂未见到公开资料。&#xA;加密过程 假设张三和李四在加密通信之前，借助通信卫星作为中介，实现一次性密钥交换的核心处理过程可能是这样的。&#xA;（1）通信卫星预先制备好一序列（比如1000组）处于纠缠态的光子。每个光子的偏振方向，是水平、垂直、45度斜角或135度斜角这四种方向之一。&#xA;（2）张三预先决定每次使用哪种滤光偏振片类型（直线型或斜角型）来从通信卫星接收这1000个光子。&#xA;（3）张三使用传统通信方式，将上述接收方案告知李四。&#xA;（4）通信卫星每次发送光子时，是先把这一组处于纠缠态的两个光子拆开来，将其中一个光子发给张三，同时将另一个光子发给李四。&#xA;（5）通信卫星向张三发送第一组光子中的一个光子。张三使用接收方案里对应于第一个光子的滤光偏振片进行接收，得到第一个光子可能的状态取值。&#xA;（6）几乎同时，通信卫星也向李四发送该组光子的另外一个光子。李四也使用相同类型的偏振片接收对应光子，也得到相同状态取值。&#xA;（7）通信卫星继续向张三、李四发送第二组光子，处理同上，直到发送完全部1000组光子。&#xA;（8）通信卫星使用传统通信方式告诉张三：这1000组光子依次是按照怎样的偏振方案（直线式或者斜角式）来发送的（但不具体告知每个光子的偏振方向究竟是垂直、水平、45度斜角还是135度斜角）。张三逐个核对后，就知道对哪些光子是使用了正确的滤光偏振片类型来接收、哪些不正确。&#xA;张三舍去用错了偏振片类型的取值，只留下用对了偏振片类型的取值后所得到的1、0序列，这就形成了一次性随机密码。&#xA;上述过程中，只有张三知道密钥（通信卫星也不知道），这是和使用“BB84协议”协商得到一次性密钥过程的主要区别所在。&#xA;（9）通信卫星使用传统方式，也将每个光子的偏振方案告诉李四。因为量子的纠缠特性，以及李四使用了和张三相同的接收方案来接收每个光子，所以，李四也会得到与张三相同的密钥。而且同样地，通信卫星也不知道密钥是什么。这相当于张三、李四安全可靠地交换了一次性随机密钥。&#xA;特别说明：&#xA;（1）通信卫星每次给张三发送光子时，是从下列两种方案中随机选择一种偏振方案：直线式或者斜角式。但是每次发给张三和李四的同一组光子，总是相同的偏振方向。&#xA;（2）张三预先准备的滤光偏振片接收方案，对每一个光子而言，其偏振片类型，也是从直线型或者斜角型中随机选择。&#xA;上述两类随机选择过程，可以确保最终生成的一次性密钥具有随机性。&#xA;如何防止密钥被窃听 存在5种被窃听的可能&#xA;假如窃听者是企图窃听通信卫星与张三之间的光子信号：对于这1000个光子，窃听者不知道该选择哪种类型的滤光偏振片来接收光子，只能随机盲目选择偏振片类型来接收。一旦用错滤光偏振片，就会引起光子偏振方向改变，当他再将光子转发给张三时，光子就不再是卫星发出时的原始偏振方向。根据“BB84”协议，最终的密钥不可能产生、而且窃听行为也会被通信卫星和张三发现。 其次，假如是窃听通信卫星与李四之间的光子信号：同样会遇到与上述（1）相同的问题。 假如是窃听张三与李四之间使用传统方式进行的通信：假设已成功窃听到接收方案，窃听者使用该接收方案去截获通信卫星发给张三或者通信卫星发给李四的光子，然后再转发给张三或李四。因为接收方案中的偏振片类型与卫星发射的光子偏振方向之间存在随机错配性，和张三或李四一样，窃听者对某一部分光子会用错偏振片类型，窃听者在截获这一部分光子时，必然引起这些光子改变偏振方向，被改变偏振方向的光子在转发给张三或者李四后，会导致通信卫星与张三或者通信卫星与李四之间无法协商产生密钥。因此，窃听行为也会失败而且也会曝光。 假如窃听者是企图窃听通信卫星与张三之间或者通信卫星与李四之间使用传统方式进行的通信内容：因为窃听时通信卫星已经将全部光子发送给了张三和李四，窃听者已没有机会更改偏振片方案去重新接收光子（量子不可克隆性），而且通信卫星和张三、李四之间仅仅交流光子偏振方案，窃密者成功截获的这一信息，也不会有任何用处。 假如是窃听或侵入通信卫星本身：根据上述密钥分发核心处理过程，通信卫星并不知晓密钥，因此，窃听通信卫星本身并不会引起密钥泄露。 量子密码技术在金融业应用分析 各行各业，也包括金融行业在内，可望基于量子密钥技术重新构建新的应用平台，为信息安全保驾护航。以金融行业为例，设想未来利用量子密钥技术进行通信加解密处理的核心过程如下。&#xA;（1）信息发送者和信息接收者事先向量子密钥分发机构申请注册。&#xA;（2）信息发送者在发送信息前，实时向量子密钥分发机构请求获得一次性量子密钥。&#xA;（3）量子密钥分发机构实时调用通信卫星提供的服务，在信息发送者和接收者之间实现一次性随机密钥的交换处理。&#xA;（4）发送者使用该密钥，利用传统的对称加密算法，对信息正文进行加密。&#xA;（5）密文通过传统信道传送给接收者。&#xA;（6）接收者使用相同密钥进行解密。&#xA;上述信息发送者和信息接收者，都可以是银行同业；或者是银行与客户。&#xA;未来社会很可能会对传统密码技术体系与生态进行重塑。在高安全性需求场景下，从上述核心处理过程可以推演出，既然密钥本身已可安全地进行交换，那么非对称密钥体制也就可能退出历史舞台。</description>
    </item>
    <item>
      <title></title>
      <link>https://seconsorl.github.io/post/bb84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/bb84/</guid>
      <description></description>
    </item>
    <item>
      <title></title>
      <link>https://seconsorl.github.io/post/%E5%90%84%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E5%88%BB%E5%90%84%E5%9C%B0%E6%97%A5%E6%9C%9F%E5%90%84%E5%9C%B0%E6%97%B6%E5%88%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>216002917@nbu.edu.cn (HZW)</author>
      <guid>https://seconsorl.github.io/post/%E5%90%84%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E5%88%BB%E5%90%84%E5%9C%B0%E6%97%A5%E6%9C%9F%E5%90%84%E5%9C%B0%E6%97%B6%E5%88%BB/</guid>
      <description></description>
    </item>
  </channel>
</rss>
