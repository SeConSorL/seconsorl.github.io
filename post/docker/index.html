<!DOCTYPE html>
<html lang="en" data-theme="light"><head>
    <title>docker · HZW</title>
    <meta charset="utf-8">
    
    <meta name="generator" content="Hugo 0.124.1">
    <meta property="og:title" content="docker" />
<meta property="og:description" content="a note for learning docker" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://seconsorl.github.io/post/docker/" /><meta property="og:image" content="https://seconsorl.github.io/images/profile.png" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-05-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-05-06T00:00:00+00:00" /><meta property="og:site_name" content="A junior from NBU" />



    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="HZW">
    
    
    
    <link rel="stylesheet" type="text/css" href="https://seconsorl.github.io/css/style.min.565d8c479597aa43658922d4b31e286529a7525a22c9546fa1018fc5e5ef6d86.css" integrity="sha256-Vl2MR5WXqkNliSLUsx4oZSmnUloiyVRvoQGPxeXvbYY=" crossorigin="anonymous" type="text/css">

    
    
    
    <script type="text/javascript" src="https://seconsorl.github.io/js/heyo-header.min.a3fa728a9f57833a31dfb45c48caaf1e4890c8c97f07bd7133fc2359745edb5d.js" integrity="sha256-o/pyip9Xgzox37RcSMqvHkiQyMl/B71xM/wjWXRe210=" crossorigin="anonymous"></script>

    
    
    <link rel="stylesheet" type="text/css" href="https://seconsorl.github.io/css/fonts.9398921f2d404983c2b7f9a68ddc72e3f5e58a3e38b0a8e4a70d75c12ebfb7c5.css" integrity="sha256-k5iSHy1ASYPCt/mmjdxy4/Xlij44sKjkpw11wS6/t8U=" crossorigin="anonymous">

    
    
    
    <script type="text/javascript" src="https://seconsorl.github.io/js/sidebar-toc.min.788b639e2ec681549740b90b3b865d5f9e1789e3ca9c06ccc45d65655434c954.js" integrity="sha256-eItjni7GgVSXQLkLO4ZdX54XiePKnAbMxF1lZVQ0yVQ=" crossorigin="anonymous"></script>

    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.min.js" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-graph.26b92ed9317bdc6f35642d588bdf3283f40998846e01cf4bee22a126907fbf3b.js" integrity="sha256-Jrku2TF73G81ZC1Yi98yg/QJmIRuAc9L7iKhJpB/vzs=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-digitalRain.af8a7b5c4428cc62d5bf49bf2698d4112c2459ee0c22c1c753ab304aef69888a.js" integrity="sha256-r4p7XEQozGLVv0m/JpjUESwkWe4MIsHHU6swSu9piIo=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-circleBrushStrokes.fe8fc3ee52e1d90e9236be8c36a27711efa024beb4da304829f95dfbb61d6e84.js" integrity="sha256-/o/D7lLh2Q6SNr6MNqJ3Ee&#43;gJL602jBIKfld&#43;7YdboQ=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sketch-meta.71b5202ea881c86ac19e4b55414656a5444204a4ba08ff7368a5aa99c0a60949.js" integrity="sha256-cbUgLqiByGrBnktVQUZWpURCBKS6CP9zaKWqmcCmCUk=" crossorigin="anonymous" defer></script>

        
        
        <script type="text/javascript" src="https://seconsorl.github.io/js/sidebar-sketch.min.2e95015880993ef9abcad62d111decea22406616931bce193254bf8af2339953.js" integrity="sha256-LpUBWICZPvmrytYtER3s6iJAZhaTG84ZMlS/ivIzmVM=" crossorigin="anonymous" defer></script>
    
    
    
    <link rel="shortcut icon" href="https://seconsorl.github.io/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="https://seconsorl.github.io/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://seconsorl.github.io/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://seconsorl.github.io/favicons/favicon-16x16.png">
    <link rel="canonical" href="https://seconsorl.github.io/post/docker/">
    
    
    
    
    

    
    <meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://seconsorl.github.io/images/profile.png" /><meta name="twitter:title" content="docker"/>
<meta name="twitter:description" content="a note for learning docker"/>

</head><body>
        <div class="main">
            <div class="page-top">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false" >
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a  href="/"  title="">Home</a></li>
        
            
            <li><a  href="/post/"  title="">Posts</a></li>
        
            
            <li><a  href="/about/"  title="">About</a></li>
        
        <li class="grow"></li>
        
        <li>
            <a class="theme-switch" title="Switch Theme">
                <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>
            <div class="sidebar" id="sidebar">
    <div class="top-toc">
        <img src="https://seconsorl.github.io/images/profile.png" alt="profile picture">
        
        <a href="/">A junior from NBU</a>
    </div>
    
    <div class="middle-sidebar grow" id="middle-sidebar">
        
            
            
                
            

            
        
    </div>

    <div class="footer">
        <ul class="social-links">
            
            <li>
                <a href="https://linkedin.com/" target="_blank" rel="noopener noreferrer" rel="me" aria-label="Linkedin">
                    <i class="fab fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
            
            <li>
                <a href="https://github.com/SeConSorL" target="_blank" rel="noopener noreferrer" rel="me" aria-label="GitHub">
                    <i class="fab fa-github" aria-hidden="true"></i>
                </a>
            </li>
            
            <li>
                <a href="https://www.instagram.com/" target="_blank" rel="noopener noreferrer" rel="me" aria-label="instagram">
                    <i class="fab fa-instagram" aria-hidden="true"></i>
                </a>
            </li>
            
            <li>
                <a href="mailto:216002917@nbu.edu.cn" target="_blank" rel="noopener noreferrer" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope" aria-hidden="true"></i>
                </a>
            </li>
            
        </ul>

        <div class="by">by HZW <b>·</b> 2025</div>
    </div>
</div>
            <div class="content">
<div class="post">
    
    <div class="thumbnail" style="box-shadow: var(--box-shadow); height: 350px;">
        <img src=https://seconsorl.github.io/images/docker.png style="object-position: 50% 70%;" title=Docker alt=Docker loading="lazy">
    </div>
    
    <div class="post-title">
        <h1>docker</h1>
        
            <div class="post-header">
    <div style="padding-top: 10px;">
        <i class="far fa-calendar"></i><span class="date">May 6, 2024</span>
        <i class="far fa-clock"></i><span class="reading-time">7 minutes</span>
        


    </div>
</div>
        
    </div>
    <div class="post-content">
        <h2 id="tip">TIP</h2>
<p>安装<a href="https://zhuanlan.zhihu.com/p/617103690">DOMJudge</a></p>
<p><a href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程</a></p>
<p><a href="https://blog.csdn.net/m0_61503020/article/details/125456520">CSDN</a></p>
<p><a href="https://www.docker.com/">Docker 官网</a>    <a href="https://www.docker.org.cn/">docker中文库</a></p>
<p><a href="https://github.com/docker/docker-ce">Github Docker 源码</a></p>
<h2 id="介绍">介绍</h2>
<p><strong>Docker</strong>，翻译过来就是码头工人</p>
<p>Docker 是dotCloud公司开源的一个基于<strong>LXC（Linux Container）<strong>的高级容器引擎，基于</strong>Go 语言</strong>并遵从 Apache2.0 协议开源。</p>
<blockquote>
<p>Linux Container 容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。LXC主要通过<strong>Kernel的namespace</strong>实现每个用户实例之间的项目隔离，通过cgroup实现对资源的配额和调度。</p>
</blockquote>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用<strong>沙箱机制</strong>，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。<strong>不依赖于任何语言、框架或者包装系统</strong></p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p>
<p><img alt="docker" src="https://www.runoob.com/wp-content/uploads/2016/04/docker01.png"></p>
<h3 id="基本原理">基本原理</h3>
<p><img alt="原理图" src="/docker_img/%E5%8E%9F%E7%90%86.png"></p>
<h4 id="docker-的cs模式">Docker 的CS模式</h4>
<p>在 Docker Client （Docker 的命令行接口）中来运行 Docker 的各种命令，这些命令会传送给在 Docker 的宿主机上运行的 Docker <a href="https://so.csdn.net/so/search?q=守护进程&spm=1001.2101.3001.7020">守护进程</a>。而 Docker 守护进程是负责实现 Docker 各种功能的。</p>
<h4 id="docker-客户端与守护进程的通信方式">Docker 客户端与守护进程的通信方式</h4>
<p>Docker 客户端与守护进程，实际上是通过 Socket 进行连接的。</p>
<p>Docker 提供了三种 Socket 连接的模式:</p>
<ul>
<li>
<p><strong>Unix</strong> 的端口模式</p>
<p>unix:///var/run/docker.sock</p>
</li>
<li>
<p><strong>TCP</strong> 协议的 host:port 模式</p>
<p>tcp://host:port</p>
</li>
<li>
<p><strong>fd</strong> 的 Socket 模式</p>
<p>fd://socketfd</p>
</li>
</ul>
<p>其中，<strong>Unix</strong> 的端口模式是 Docker 默认的客户端与守护进程的连接方式。我们也可以通过配置进行修改，来修改 Socket 连接方式。</p>
<h3 id="docker容器技术与虚拟机的区别">Docker容器技术与虚拟机的区别</h3>
<p><img alt="dockerVSvm" src="/docker_img/dockerVSvm.png"></p>
<p><strong>相同点</strong>：docker和容器技术和虚拟机技术，都是虚拟化技术。</p>
<p><strong>不同点</strong>：docker有着比虚拟机<strong>更少的抽象层</strong>。 由于<strong>docker不需要Hypervisor实现硬件资源虚拟化</strong>，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。所以<strong>docker效率比虚拟机效率高。达到了秒级启动的地步</strong>。</p>
<p><strong>docker相较于VM的优点：</strong></p>
<p>1、比VM小、快，Docker容器的尺寸减小相比于整个虚拟机大大简化了分布到云和分发时间的开销。Docker启动一个容器实例时间仅仅需要几秒钟。</p>
<p>2、Docker是一个开放的平台，构建、发布和运行分布式应用程序。</p>
<p>3、开发人员不需要关系具体是哪个Linux操作系统</p>
<p>4、Google、微软（azure）、亚马逊、IBM等都支持docker。</p>
<p>5、Docker支持Unix/Linux操作系统，也支持Windows和Mac。</p>
<p><strong>Docker局限性：</strong></p>
<p>Docker用于应用程序时是最有用的，但并不包含数据。日志、数据库等通常放在Docker容器外。一个容器的镜像通常都很小，不用和存储大量数据，存储可以通过外部挂载等方式使用，比如：NFS、ipsan、MFS等 ，或者docker命令 ，-v映射磁盘分区。</p>
<p>总之，docker只用于计算，存储交给别人。</p>
<p><img alt="docker架构图" src="https://img-blog.csdnimg.cn/5ac27867aa3544e5b40f30b4d27f5e5a.png#pic_center"></p>
<h3 id="工作流程">工作流程</h3>
<p>1、启动docker</p>
<p>2、下载镜像到本地</p>
<p>3、启动docker容器实例</p>
<blockquote>
<p>（注册一个dockerhub）</p>
</blockquote>
<p>==Docker核心技术:==
1、<strong>Namespace</strong> —&gt; 实现Container的进程、网络、消息、文件系统和主机名的隔离。
2、<strong>Cgroup</strong> —&gt; 实现对资源的配额和调度。</p>
<blockquote>
<p>注意：Cgroup的配额，可以指定实例使用的CPU个数，内存大小等。</p>
</blockquote>
<h3 id="docker的应用场景">Docker的应用场景</h3>
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li>文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。</li>
<li>资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。</li>
<li>网络隔离：每个进程容器运行在自己的网路空间，虚拟接口和IP地址。</li>
<li>日志记录：Docker将收集到和记录的每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或者批量检索</li>
<li>变更管理：容器文件系统的变更可以提交到新的镜像中，并可重复使用以创建更多的容器。无需使用模板或者手动配置。</li>
<li>交互式shell：Docker可以分配一个虚拟终端并且关联到任何容器的标准输出上，例如运行一个一次性交互shell。</li>
</ul>
<h3 id="优点">优点</h3>
<p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 能够将应用程序与基础架构分开，从而可以快速交付软件。</p>
<p>借助 Docker，可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<p><strong>1、快速，一致地交付您的应用程序</strong></p>
<p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p>
<p><strong>2、响应式部署和扩展</strong></p>
<p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p>
<p>Docker 的可移植性和轻量级的特性，可以轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
<p><strong>3、在同一硬件上运行更多工作负载</strong></p>
<p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p>
<h2 id="安装ubuntu">安装（Ubuntu）</h2>
<p><a href="https://docs.docker.com/engine/install/ubuntu/">Ubuntu安装Docker官方文档</a></p>
<p>Docker最早的版本名是docker和docker-engin，现在的名字是docker-ce和docker-ee。</p>
<p>2017年初，docker公司将原先的docker开源项目改名为<strong>moby</strong>。<strong>moby</strong>是集成了原先的docker项目，是社区维护的开源项目，谁都可以在moby的基础打造自己的容器产品。</p>
<p><strong>docker-ce</strong> 是docker公司维护的开源项目，是一个基于moby项目的免费容器产品。</p>
<blockquote>
<p>注：moby是源代码，docker-ce 和docker-ee 是产品容器，rpm包。</p>
</blockquote>
<h3 id="yum安装">yum安装</h3>
<p><strong>安装docker依赖环境。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span></code></pre></div><p><strong>配置国内docker-ce的yum源（这里采用的是阿里云）</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># yum-config-manager命令作用是添加yum源。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># 配置成功。</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">cd</span> /etc/yum.repos.d
</span></span><span style="display:flex;"><span>ls
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#有docker-ce.repo就代表配置成功</span>
</span></span></code></pre></div><p><strong>安装docker</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum -y install docker-ce doker-ce-cli containerd.io
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#如果不知道包名的作用，可以使用yum info 程序 命令查看</span>
</span></span></code></pre></div><p><strong>开启网络转发功能</strong></p>
<p>默认会自动开启。</p>
<p>路径 ：<code>/proc/sys/net/ipv4/ip_forward</code></p>
<p>手动开启：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vim /etc/sysctl.conf   <span style="color:#6272a4">#插入以下内容</span>
</span></span><span style="display:flex;"><span>net.ipv4.forward <span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sysctl -p   <span style="color:#6272a4">#生效</span>
</span></span><span style="display:flex;"><span>cat /proc/sys/net/ipv4/ip_forward  <span style="color:#6272a4">#查看结果，为1开启成功。</span>
</span></span></code></pre></div><p><strong>关闭防火墙</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>iptables -nL <span style="color:#6272a4">#查看一下iptable规则，关闭防火墙后会自动插入新规则</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>systemctl stop firewalld <span style="color:#ff79c6">&amp;&amp;</span> systemctl disable firewalld  <span style="color:#6272a4">#关闭防火墙</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sysctlrem restart docker <span style="color:#6272a4"># 关闭防火墙要把docker重启一下，不然docker的ip包转发功能无法使用。即便防火墙关闭了，docker依旧会调用内核模块netfilter增加规则，所以会新增iptables规则</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>iptables -nL <span style="color:#6272a4">#再查看一下iptable规则，会发现多出很多规则  TARGET里有DOCKER</span>
</span></span></code></pre></div><p><strong>启动服务</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl start docker <span style="color:#ff79c6">&amp;&amp;</span> systemctl <span style="color:#8be9fd;font-style:italic">enable</span> docker
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#启动完后 这里ip转发会自动变成1。默认0</span>
</span></span><span style="display:flex;"><span>cat /proc/sys/net/ipv4/ip_forward  <span style="color:#6272a4">#查看结果，为1开启成功。</span>
</span></span></code></pre></div><p>查看docker版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker version <span style="color:#6272a4">#安装完后查看docker版本</span>
</span></span></code></pre></div><p>这里可以看到docker是一个C/S架构的模式。客户端是我们的命令行操作，服务端是一个守护进程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker info  <span style="color:#6272a4">#查看docker基本信息</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#docker root dir 是 docker镜像的地址</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#registry 是 docker仓库的地址</span>
</span></span></code></pre></div><p>我们可以通过<code>docker info</code>看到机器存放docker镜像的地址，也可以看到docker仓库的地址。</p>
<h3 id="使用官方安装脚本自动安装">使用官方安装脚本自动安装</h3>
<p>安装命令如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> curl -fsSL https://test.docker.com -o test-docker.sh
</span></span><span style="display:flex;"><span> sudo sh test-docker.sh
</span></span></code></pre></div><h3 id="手动安装">手动安装</h3>
<h4 id="卸载旧版本">卸载旧版本</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo apt-get remove docker docker-engine docker.io containerd runc
</span></span></code></pre></div><h4 id="安装-docker-engine-community">安装 Docker Engine-Community</h4>
<p><strong>使用 Docker 仓库进行安装</strong></p>
<p>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker 。</p>
<p><strong>设置仓库</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 更新 apt 包索引。</span>
</span></span><span style="display:flex;"><span>$ sudo apt-get update
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#安装 apt 依赖包，用于通过HTTPS来获取仓库:</span>
</span></span><span style="display:flex;"><span>$ sudo apt-get install <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    apt-transport-https <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    ca-certificates <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    curl <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    gnupg-agent <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    software-properties-common
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#添加 Docker 的官方 GPG 密钥：</span>
</span></span><span style="display:flex;"><span>$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
</span></span></code></pre></div><h3 id="镜像源替换">镜像源替换</h3>
<p><a href="https://zhuanlan.zhihu.com/p/24461370776">国内镜像源</a></p>
<h2 id="docker-的技术实现">Docker 的技术实现</h2>
<p>Docker 的实现，主要归结于三大技术：</p>
<ul>
<li>命名空间 ( Namespaces )</li>
<li>控制组 ( Control Groups )</li>
<li>联合文件系统 ( Union File System )</li>
</ul>
<h3 id="namespace">Namespace</h3>
<p><strong>命名空间</strong>是 Linux 核心在 2.4 版本后逐渐引入的一项用于运行隔离的模块。</p>
<p>在编程语言中，命名空间的主要目的就是为了集合相同模块的类，区分不同模块间的同名类。</p>
<p>同样的道理，Linux 内核的命名空间，就是能够将计算机资源进行切割划分，形成各自独立的空间。</p>
<p>就实现而言，<strong>Linux Namespaces</strong> 可以分为很多具体的子系统，如 <strong>User Namespace</strong>、<strong>Net Namespace</strong>、<strong>PID Namespace</strong>、<strong>Mount Namespace</strong> 等等。</p>
<p>以进程为例，通过 PID Namespace，我们可以造就一个独立的进程运行空间，在其中进程的编号又会从 1 开始。在这个空间中运行的进程，完全感知不到外界系统中的其他进程或是其他进程命名空间中运行的进程。</p>
<p><img alt="命名空间举例" src="/docker_img/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%BE%E4%BE%8B.png"></p>
<p>Namespace 它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离。</p>
<h3 id="control-groups">Control Groups</h3>
<p><strong>资源控制组 ( 常缩写为 CGroups )</strong> 是 Linux 内核在 2.6 版本后逐渐引入的一项对计算机资源控制的模块。</p>
<p>顾名思义，资源控制组的作用就是控制计算机资源的。与以隔离进程、网络、文件系统等虚拟资源为目的 Namespace 不同，CGroups <strong>主要做的是硬件资源的隔离</strong>。</p>
<p>之前我们提到了，虚拟化除了制造出虚拟的环境隔离同一物理平台运行的不同程序之外，另一大作用就是控制硬件资源的分配，CGroups 的使用正是为了这样的目的。
<img alt="资源控制组" src="g:\\Manual\\docker_img\\资源控制组.png"></p>
<p>通过 CGroups，我们可以指定任意一个隔离环境对任意资源的占用值或占用率，这对于很多分布式使用场景来说是非常有用的功能。</p>
<p>例如，我们在服务器上部署一个业务服务和一个健康监控服务。通常情况下，监控服务只会占用很少的计算机资源，但我们无法保证其不会因为一些逻辑问题产生 Bug 进而过分消耗计算机资源。而它申请的计算机资源越多，意味着业务服务所能使用的计算机资源也就越少，最后甚至可能造成物理服务器的崩溃。</p>
<p>上述的问题在没有隔离实现的普通运行环境下是比较难解决的，因为所有不从系统层面出发的限制程序资源使用的方式都并不完全有效。由于 CGroups 实现于操作系统，而操作系统垄断着系统资源的分配，所以其完全能够限制隔离环境下应用的资源占有量。</p>
<h3 id="union-file-system">Union File System</h3>
<p><strong>联合文件系统 ( Union File System )</strong> 是一种能够同时挂载不同实际文件或文件夹到同一目录，形成一种联合文件结构的文件系统。联合文件系统本身与虚拟化并无太大的关系，但 Docker 却创新的将其引入到容器实现中，用它解决虚拟环境对文件系统占用过量，实现虚拟环境快速启停等问题。</p>
<p>在 Docker 中，提供了一种对 <strong>UnionFS</strong> 的改进实现，也就是 <strong>AUFS ( Advanced Union File System )</strong>。</p>
<p><img alt="联合文件系统" src="g:\\Manual\\docker_img\\联合文件系统.png"></p>
<p>AUFS 将文件的更新挂载到老的文件之上，而不去修改那些不更新的内容，这就意味着即使虚拟的文件系统被反复修改，也能保证对真实文件系统的空间占用保持一个较低水平。</p>
<h2 id="docker平台的基本使用方法">Docker平台的基本使用方法。</h2>
<h3 id="帮助命令">帮助命令</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker version     <span style="color:#6272a4">#显示docker详细信息</span>
</span></span><span style="display:flex;"><span>docker info       <span style="color:#6272a4">#显示docker的系统信息，包括镜像和容器的数量</span>
</span></span><span style="display:flex;"><span>docker --help     <span style="color:#6272a4">#docker帮助命令手册</span>
</span></span></code></pre></div><h3 id="镜像命令">镜像命令</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker images  <span style="color:#6272a4">#查看所有本地主机的镜像</span>
</span></span><span style="display:flex;"><span>docker search 镜像名           <span style="color:#6272a4">#搜索镜像</span>
</span></span><span style="display:flex;"><span>docker pull 镜像名 <span style="color:#ff79c6">[</span>标签<span style="color:#ff79c6">]</span>      <span style="color:#6272a4">#下载镜像（如果不写tag，默认是latest）</span>
</span></span><span style="display:flex;"><span>docker rmi 镜像名 <span style="color:#ff79c6">[</span>标签<span style="color:#ff79c6">]</span>       <span style="color:#6272a4">#删除镜像    docker rmi -f $(docker images -aq)  删除全部镜像</span>
</span></span><span style="display:flex;"><span>docker tag  镜像名:版本   新镜像名:版本    <span style="color:#6272a4">#复制镜像并且修改名称</span>
</span></span><span style="display:flex;"><span>docker commit  -a <span style="color:#f1fa8c">&#34;xxx&#34;</span>  -c <span style="color:#f1fa8c">&#34;xxx&#34;</span> 镜像ID 名字：版本   <span style="color:#6272a4">#提交镜像 </span>
</span></span><span style="display:flex;"><span>-a :提交的镜像作者；
</span></span><span style="display:flex;"><span>-c :使用Dockerfile指令来创建镜像；
</span></span><span style="display:flex;"><span>-m :提交时的说明文字；
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>docker load -i    /xxx/xxx.tar         <span style="color:#6272a4">#导入镜像</span>
</span></span><span style="display:flex;"><span>docker save -o   /xxx/xxx.tar          <span style="color:#6272a4">#保存一个镜像为一个tar包</span>
</span></span></code></pre></div><h3 id="容器命令">容器命令</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run <span style="color:#ff79c6">[</span>可选参数<span style="color:#ff79c6">]</span> image 命令 <span style="color:#6272a4">#启动容器（无镜像会先下载镜像）</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#参数说明</span>
</span></span><span style="display:flex;"><span>--name <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;Name&#34;</span>   容器名字
</span></span><span style="display:flex;"><span>-c   后面跟待完成的命令
</span></span><span style="display:flex;"><span>-d   以后台方式运行并且返回ID，启动守护进程式容器
</span></span><span style="display:flex;"><span>-i   使用交互方式运行容器，通常与t同时使用
</span></span><span style="display:flex;"><span>-t   为容器重新分配一个伪输入终端。也即启动交互式容器
</span></span><span style="display:flex;"><span>-p   指定容器端口    -p 容器端口:物理机端口  映射端口
</span></span><span style="display:flex;"><span>-P   随机指定端口
</span></span><span style="display:flex;"><span>-v   给容器挂载存储卷
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>docker build  <span style="color:#6272a4">#创建镜像        -f：指定dockerfile文件路径   -t：镜像名字以及标签</span>
</span></span><span style="display:flex;"><span>docker logs 容器实例的ID          <span style="color:#6272a4">#查看容器日志</span>
</span></span><span style="display:flex;"><span>docker rename 旧名字  新名字      <span style="color:#6272a4"># 给容器重新命名</span>
</span></span><span style="display:flex;"><span>docker top    容器实例的ID                  <span style="color:#6272a4">#查看容器内进程</span>
</span></span><span style="display:flex;"><span>docker ps -a                    <span style="color:#6272a4">#列出所有容器（不加-a就是在运行的）</span>
</span></span><span style="display:flex;"><span>docker rm      容器实例的ID                 <span style="color:#6272a4">#删除容器（正在运行容器不能删除，除非加-f选项）</span>
</span></span><span style="display:flex;"><span>docker <span style="color:#8be9fd;font-style:italic">kill</span>  容器实例的ID        <span style="color:#6272a4">#杀掉容器</span>
</span></span><span style="display:flex;"><span>docker <span style="color:#8be9fd;font-style:italic">history</span>   容器实例的ID    <span style="color:#6272a4">#查看docker镜像的变更历史</span>
</span></span><span style="display:flex;"><span>docker start 容器实例的ID        <span style="color:#6272a4">#启动容器</span>
</span></span><span style="display:flex;"><span>docker restart 容器实例的ID       <span style="color:#6272a4">#重启容器</span>
</span></span><span style="display:flex;"><span>docker stop 容器实例的ID         <span style="color:#6272a4">#停止正在运行的容器</span>
</span></span><span style="display:flex;"><span>docker attach /docker <span style="color:#8be9fd;font-style:italic">exec</span>  容器实例的ID   <span style="color:#6272a4">#同为进入容器命令，不同的是attach连接终止会让容器退出后台运行，而exec不会。并且，docker attach是进入正在执行的终端，不会情动新的进程，而docker exec则会开启一个新的终端，可以在里面操作。</span>
</span></span><span style="display:flex;"><span>docker image inspect  容器名称：容器标签       <span style="color:#6272a4">#查看容器内源数据</span>
</span></span><span style="display:flex;"><span>docker cp  容器id：容器内路径   目的主机路径           <span style="color:#6272a4">#从容器内拷贝文件到主机（常用）或者从主机拷贝到容器（一般用挂载）</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">exit</span>                           <span style="color:#6272a4">#直接退出容器 </span>
</span></span><span style="display:flex;"><span>crlt + P + Q                   <span style="color:#6272a4">#退出容器但是不终止运行</span>
</span></span></code></pre></div><h3 id="docker-常用接口">Docker 常用接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>curl http://10.49.44.14:5678/info // 相当于在本地 docker info访问
</span></span><span style="display:flex;"><span>curl http://10.49.44.14:5678/containers/json // 返回活动的容器
</span></span><span style="display:flex;"><span>curl http://10.49.44.14:5678/containers/json?all<span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span> // 返回所有容器
</span></span><span style="display:flex;"><span>curl http://10.49.44.14:5678/images/json
</span></span><span style="display:flex;"><span>在linux下，可以通过curl工具访问url，因为返回的是json串，非格式化的。可以结合python命令，转为格式化的json，让看起来比较清。如：
</span></span><span style="display:flex;"><span>curl http://10.49.44.14:5678/images/json | python -mjson.tool
</span></span></code></pre></div><h2 id="容器container">容器（container）</h2>
<h3 id="镜像运行时的实体">镜像运行时的实体</h3>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p>
<p><u>容器的实质是进程</u>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。</p>
<h3 id="生存周期">生存周期</h3>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。</p>
<p>容器启动后，我们可以在容器中创建文件，写入文件；但是当容器stop后，这些数据都会消失。</p>
<p>如果想要持久化容器的数据，可以数据卷（Volume）来绑定宿主机的目录，在这些位置的读写会跳过容器存储层，直接对宿主机（或网络存储）发生读写，其性能和稳定性更高。</p>
<blockquote>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run，数据却不会丢失。</p>
</blockquote>
<h3 id="简单容器命令">简单容器命令</h3>
<h4 id="启停">启停</h4>
<h5 id="创建容器docker-create">创建容器（docker create）</h5>
<p>命令：<code>docker create &lt;image_name&gt;</code></p>
<p>创建一个基于<code>image_name</code>镜像的新容器。若主机中没有对应镜像，将会从<code>docker Hub</code>中拉取最新镜像。</p>
<h5 id="查看容器信息">查看容器信息</h5>
<p><code>docker ps</code> 命令表示列出所有<strong>在运行</strong>的容器信息</p>
<p><code>docker ps -a</code> 命令显示<strong>所有</strong>的容器，包括未运行的</p>
<table>
<thead>
<tr>
<th style="text-align:center">CONTAINER ID</th>
<th style="text-align:center">IMAGE</th>
<th style="text-align:center">COMMAND</th>
<th style="text-align:center">CREATED</th>
<th style="text-align:center">STATUS</th>
<th style="text-align:center">PORTS</th>
<th style="text-align:center">NAMES</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">容器ID</td>
<td style="text-align:center">基于的镜像</td>
<td style="text-align:center">正在执行的命令</td>
<td style="text-align:center">创建时间</td>
<td style="text-align:center">状态</td>
<td style="text-align:center">端口</td>
<td style="text-align:center">名字</td>
</tr>
</tbody>
</table>
<h5 id="启动容器docker-start">启动容器（docker start）</h5>
<p>根据容器ID或容器名称启动容器</p>
<p><code>docker start &lt;ID&gt;</code></p>
<h5 id="停止和重启容器">停止和重启容器</h5>
<p>停止：<code>docker stop &lt;ID&gt;</code></p>
<p>重启：<code>docker restart &lt;ID&gt;</code></p>
<h5 id="暂停和恢复容器">暂停和恢复容器</h5>
<p>暂停：<code>docker pause &lt;ID&gt; </code></p>
<p>恢复：<code>docker unpause &lt;ID&gt;</code></p>
<h5 id="杀掉容器进程强制停止容器">杀掉容器进程，强制停止容器</h5>
<p><code>docker kill &lt;ID&gt;</code></p>
<h5 id="重命名">重命名</h5>
<p><code>docker rename &lt;container ID&gt; new-name</code></p>
<h4 id="运行">运行</h4>
<p><strong>运行新容器</strong></p>
<p>如下命令：<code>docker run ubuntu:14.04 /bin/echo 'Hello world'</code></p>
<p>该容器基于<code>ubuntu:14.04</code>。若主机中没有对应镜像，将会从<code>docker Hub</code>中拉取最新镜像；同时还会执行<code>echo</code>命令输出<code>Hello world</code></p>
<p><strong>启动一个 bash 终端</strong></p>
<p><code>docker run -it ubuntu:14.04 /bin/bash</code></p>
<p>接下来的操作会在容器内进行</p>
<ul>
<li>
<p><strong>-it</strong> ：这是两个参数，一个是 <strong>-i</strong> ：交互式操作，一个是 <strong>-t</strong> 终端。我们这里打算进入bash执行一些命令并查看返回结果，因此我们需要交互式终端。</p>
</li>
<li>
<p><strong>bash</strong> ：这里我们希望有个交互式Shell，因此用的是bash。</p>
</li>
</ul>
<p><strong>执行exit命令可以退出容器</strong></p>
<h4 id="进入容器">进入容器</h4>
<p>可以使用<code>docker attach</code>命令或<code>docker exec</code>命令</p>
<ul>
<li>
<p><code>docker attach &lt;容器ID&gt; or &lt;容器名称&gt;</code></p>
</li>
<li>
<p><code>docker exec -it &lt;container ID&gt; bash</code></p>
</li>
</ul>
<p><strong>执行exit命令可以退出容器</strong></p>
<h4 id="删除">删除</h4>
<ul>
<li>
<p><code>docker rm</code> 来删除一个处于终止状态的容器。若容器没有退出则无法删除，需要先停止容器。</p>
</li>
<li>
<p><code>docker rm -f</code>来删除一个处于运行状态的容器。若容器暂停则无法删除，需要先恢复容器。</p>
</li>
<li>
<p><code>docker rm -v $(docker ps -aq -f status=exited)</code>删除所有已终止的容器</p>
</li>
</ul>
<h2 id="镜像image">镜像（image）</h2>
<h3 id="原理">原理</h3>
<h4 id="镜像是什么">镜像是什么？</h4>
<p>镜像是一种轻量级的、可执行的<strong>独立软件包</strong>。用来<strong>打包软件运行环境和基于运行环境的开发软件</strong>，它包含运行某个软件所需要的内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="docker镜像加载原理">Docker镜像加载原理</h4>
<p><strong>UnionFS（联合文件系统）</strong></p>
<p>UnionFS（联合文件系统）：UnionFS文件系统是一种分层、轻量级并且高性能的文件系统。它支持对文件系统的修改作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。<strong>Union文件系统是Docker镜像的基础</strong>。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种各样的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但是从外面开起来，只能看一个文件系统，联合加载会把各层文件系统叠加起来，最终的文件系统会包含所有的底层文件和目录。</p>
<p><strong>Docker镜像加载原理</strong></p>
<p>docker的镜像实际上是由一层一层的文件系统组成，这种层级关系就叫<strong>UnionFS</strong>。</p>
<p><strong>bootfs</strong>（boot file system）主要包括bootloader和kernel。</p>
<p>bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就在内存中了，此时内存的使用权由bootfs转交给内核，此时系统会卸载bootfs。</p>
<p><strong>rootfs</strong>（root file system），在bootfs之上。包含的就是典型Linux系统的/dev, /proc, /bin, /etc等等标准文件。rootfs就是各种不同的操作系统发行版本，比如Ubuntu、CentOS等。</p>
<blockquote>
<p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令、工具和程序即可，因为底层直接用Host的kernel，自己只需要提供rootfs即可。由此可见不同的Linux发行版本，<strong>bootfs基本上是一致的</strong>，rootfs会有差别，所以<strong>不同的发行版可以公用bootfs</strong>，这也是一个镜像仅有几百MB的原因。</p>
</blockquote>
<h4 id="分层理解">分层理解</h4>
<p>举例，用<code>docker pull nginx</code>命令可以看到下载的文件的形式是一层一层的。</p>
<p>**docker为什么会使用这种方法呢？**最大的好处，就是==资源共享==。比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需要在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有容器提供服务了，而且镜像的每一层都可以被共享。</p>
<p>通过<code>docker image inspect ngixn:latest</code>查看一下。会看到<strong>RootFS</strong>的<strong>layers</strong>中有多层。</p>
<p>所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的<strong>第一层</strong>；如果在该镜像中添加Python包，就会在基础镜像之上创建<strong>第二个镜像层</strong>；如果继续添加安全补丁，就会创建<strong>第三个镜像层</strong>。</p>
<p>在添加额外的镜像的同时，<strong>镜像始终是当前所有镜像的组合</strong>。==docker镜像都是<strong>只读</strong>的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层就是我们所说的容器层，容器之下都叫镜像层。==</p>
<h4 id="提交镜像">提交镜像</h4>
<h5 id="命令">命令</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker commit 提交容器成为一个新的副本
</span></span><span style="display:flex;"><span>docker commit -m<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;提交的描述信息&#34;</span>  -a<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;作者&#34;</span>  容器id  目标镜像名:<span style="color:#ff79c6">[</span>TAG<span style="color:#ff79c6">]</span>
</span></span></code></pre></div><h5 id="实验">实验</h5>
<p>1、拉取一个tomcat镜像</p>
<p>2、启动tomcat。<code>docker run -itd -p 8080:8080 tomcat:latest /bin/bash</code></p>
<p>3、然后进入此容器<code>docker exec -it [容器ID] /bin/bash</code></p>
<p>4、默认tomcat镜像的webapp网页文件里是没有东西的，要从webapps.dist中把它拷贝出来。在<code>/usr/local/tomcat/</code> 中执行 <code>cp -r webapps.dist/* webapps</code></p>
<p>5、打开8080端口，在浏览器访问tomcat docker</p>
<p>6、提交镜像。<code>docker commit -a=“This my create tomcat” -m=“add webapps app” 81 tomcat02:1.0</code></p>
<p>查看<code>docker images</code>就可以看到制作的镜像</p>
<h3 id="简单镜像命令">简单镜像命令</h3>
<h4 id="搜索镜像docker-search"><strong>搜索镜像（docker search）</strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker search centos <span style="color:#6272a4">#从docker hub中搜索docker名为centos的镜像</span>
</span></span></code></pre></div><p>这里会提供一下信息：</p>
<ul>
<li><strong>name</strong>:代表此镜像的名称</li>
<li><strong>description</strong>：此镜像的描述</li>
<li><strong>stars</strong>：下载次数</li>
<li><strong>official</strong>：是否由官方提供（官方提供可放心下载，可以基于此镜像做自己的镜像）</li>
</ul>
<h4 id="拉取镜像docker-pull"><strong>拉取镜像（docker pull）</strong></h4>
<p>默认是拉去docker hub上搜索到的最新版本（第一个）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull centos  <span style="color:#6272a4">#拉去名为centos的最新的镜像</span>
</span></span></code></pre></div><p>这里pull的时候的格式为<code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></p>
<p><code>标签</code>表示镜像的版本，不写默认是<code>latest</code></p>
<p>==如果TLS handshake timeout，配置镜像加速==</p>
<p>使用<a href="https://cr.console.aliyun.com">阿里云docker镜像加速器</a>的控制台，使用支付宝账号登录，左侧加速器帮助页面会为显示<strong>独立的加速地址</strong>，这个加速地址每个人的都不同。</p>
<p><strong>可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器。把自己的专属加速地址放到下面的地址改一下，写入文件就可以了。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4">#文件中的修改内容</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f1fa8c">&#34;registry-mirrors&#34;</span>: <span style="color:#ff79c6">[</span><span style="color:#f1fa8c">&#34;https://eu5rxjvf.mirror.aliyuncs.com&#34;</span><span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>systemctl daemon-reload  <span style="color:#6272a4">#启动配置</span>
</span></span><span style="display:flex;"><span>systemctl restart docker  <span style="color:#6272a4">#重启docker服务</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#docker info查看一下是否新增了阿里云的地址，在Registry Mirrors中会有地址</span>
</span></span></code></pre></div><h4 id="查看镜像docker-images">查看镜像（docker images）</h4>
<p>拉去之后使用<code>docker images</code>查看已下载镜像。</p>
<table>
<thead>
<tr>
<th style="text-align:center">REPOSITORY</th>
<th style="text-align:center">TAG</th>
<th style="text-align:center">IMAGE ID</th>
<th style="text-align:center">CREATED</th>
<th style="text-align:center">SIZE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">镜像名，可以自定义</td>
<td style="text-align:center">标签，表示版本</td>
<td style="text-align:center">编号（unique）</td>
<td style="text-align:center">创建时间</td>
<td style="text-align:center">镜像大小</td>
</tr>
</tbody>
</table>
<p>还可以使用<code>docker image ls</code>来查看</p>
<p><code>docker image ls nginx</code>可以查看名字为<code>nginx</code>的镜像</p>
<p><strong>查看镜像的大小</strong></p>
<p><code>docker system df</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">TYPE</th>
<th style="text-align:center">TOTAL</th>
<th style="text-align:center">ACTIVE</th>
<th style="text-align:center">SIZE</th>
<th style="text-align:center">RECLAIMABLE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类型（镜像、容器、数据卷等）</td>
<td style="text-align:center">个数</td>
<td style="text-align:center">处于活跃的状态</td>
<td style="text-align:center">总大小</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="删除镜像docker-rmi">删除镜像（docker rmi）</h4>
<p>命令：<code>docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p>
<ul>
<li>
<p>通过短ID或镜像完整ID删除镜像（<strong>ID</strong>就是<strong>IMAGE ID</strong>）</p>
</li>
<li>
<p>可以通过<code>仓库名+标签</code>删除镜像，如果删除的镜像已经产生了容器实例。不管容器实例是否启动都会提示<strong>无法删除</strong>，因为镜像被占用。这时需要先<strong>删除容器实例</strong>或<strong>添加删除参数</strong></p>
<blockquote>
<p>-f :强制删除，一般用于被占用的删除。</p>
</blockquote>
</li>
</ul>
<h4 id="使用u盘和网络下载方式导入镜像">使用U盘和网络下载方式导入镜像</h4>
<p>把docker-centos-httpd.tar镜像上传到linux上，就需要用到<code>docker load -i</code> 命令</p>
<p><code>docker load -i /root/docker-centos-httpd.tar</code></p>
<blockquote>
<p>docker镜像相当于对程序+程序依赖的库直接打包</p>
</blockquote>
<p>还有直接下载其他站点镜像的方法，命令如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull hub.c.163.com/library/&lt;registry&gt;:latest
</span></span></code></pre></div><h2 id="仓库registry">仓库（registry）</h2>
<p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个仓库（<strong>Repository</strong>）；每个仓库可以包含多个标签（<strong>Tag</strong>）；<strong>每个标签对应一个镜像</strong>。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/"><strong>Docker Hub</strong></a>（<u>需要翻墙</u>），这也是默认的 Registry，并拥有大量的高质量的官方镜像。</p>
<h2 id="dockfile">Dockfile</h2>
<h3 id="关于dockerfile">关于dockerfile</h3>
<p>虽然我们可以通过<code>docker commit</code>命令来手动创建镜像，但是通过Dockerfile文件，可以帮助我们自动创建镜像，并且能够自定义创建过程。</p>
<p>本质上，<strong>Dockerfile</strong>就是由一系列命令和参数构成的<strong>脚本</strong>，这些命令应用于基础镜像并最终创建一个新的镜像。它简化了从头到尾的构建流程并极大的简化了部署工作。使用dockerfile构建镜像有以下好处：</p>
<ul>
<li>像编程一样构建镜像，支持分层构建以及缓存；</li>
<li>可以快速而精确地重新创建镜像以便于维护和升级；</li>
<li>便于持续集成；</li>
<li>可以在任何地方快速构建镜像</li>
</ul>
<h3 id="dockerfile指令">Dockerfile指令</h3>
<h4 id="from">FROM</h4>
<p><code>FROM</code> 指令用于设置在新映像创建过程期间将使用的容器映像。</p>
<p>示例：</p>
<p><code>FROM nginx</code></p>
<p><code>FROM microsoft/dotnet:2.1-aspnetcore-runtime</code></p>
<h4 id="run">RUN</h4>
<p><code>RUN</code> 指令指定将要运行并捕获到新容器映像中的命令。 这些命令包括安装软件、创建文件和目录，以及创建环境配置等。</p>
<p>格式：</p>
<p><code>RUN [&quot;&quot;, &quot;&quot;, &quot;&quot;]  相当于CMD</code>      <code>RUN  &lt;在终端操作的shell命令&gt;</code></p>
<blockquote>
<p>Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff79c6">FROM</span><span style="color:#f1fa8c"> centos</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">RUN</span> yum -y install wget
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">RUN</span> wget -O redis.tar.gz <span style="color:#f1fa8c">&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">RUN</span> tar -xvf redis.tar.gz
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#以上执行会创建 3 层镜像。可简化为以下格式：</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">FROM</span><span style="color:#f1fa8c"> centos</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">RUN</span> yum -y install wget <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>  <span style="color:#ff79c6">&amp;&amp;</span> wget -O redis.tar.gz <span style="color:#f1fa8c">&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span> <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>  <span style="color:#ff79c6">&amp;&amp;</span> tar -xvf redis.tar.gz
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#如上，以&amp;&amp;符号连接命令，这样执行后，只会创建 1 层镜像。</span>
</span></span></code></pre></div><h4 id="cmd">CMD</h4>
<p>类似于 <code>RUN</code> 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在<strong>docker run</strong> 时运行。</li>
<li>RUN 是在 <strong>docker build</strong>。</li>
</ul>
<p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。<code>CMD</code> 指令指定的程序可被 <strong>docker run</strong> 命令行参数中指定要运行的程序所覆盖。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，<strong>仅最后一个生效</strong>。</p>
<p>格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff79c6">CMD</span> &lt;shell 命令&gt; 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CMD</span> [<span style="color:#f1fa8c">&#34;&lt;可执行文件或命令&gt;&#34;</span>,<span style="color:#f1fa8c">&#34;&lt;param1&gt;&#34;</span>,<span style="color:#f1fa8c">&#34;&lt;param2&gt;&#34;</span>,...] 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CMD</span> [<span style="color:#f1fa8c">&#34;&lt;param1&gt;&#34;</span>,<span style="color:#f1fa8c">&#34;&lt;param2&gt;&#34;</span>,...]  <span style="color:#6272a4"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span>
</span></span></code></pre></div><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p>
<h4 id="entrypoint">ENTRYPOINT</h4>
<p>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。每个 Dockerfile 中<strong>只能有一个</strong><code>ENTRYPOINT</code>，当指定多个时，<strong>只有最后一个起效</strong>。</p>
<p>格式：<code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></p>
<p><code>ENTRYPOINT [&quot;dotnet&quot;, &quot;Magicodes.Admin.Web.Host.dll&quot;]</code></p>
<p>可以搭配 <code>CMD</code> 命令使用：一般是变参才会使用 <code>CMD</code> ，这里的 <code>CMD</code> 等于是在给 <code>ENTRYPOINT</code> 传参。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff79c6">ENTRYPOINT</span> [<span style="color:#f1fa8c">&#34;nginx&#34;</span>, <span style="color:#f1fa8c">&#34;-c&#34;</span>] <span style="color:#6272a4"># 定参</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">CMD</span> [<span style="color:#f1fa8c">&#34;/etc/nginx/nginx.conf&#34;</span>] <span style="color:#6272a4"># 变参 </span>
</span></span><span style="display:flex;"><span>$ docker run  nginx:test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ docker run  nginx:test -c /etc/nginx/new.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#以上两个均会执行nginx -c /etc/nginx/nginx.conf</span>
</span></span></code></pre></div><blockquote>
<p>如果运行 <code>docker run</code> 时使用了 <code>--entrypoint</code> 选项，将<strong>覆盖</strong> ENTRYPOINT 指令指定的程序。</p>
</blockquote>
<h4 id="copy">COPY</h4>
<p><code>COPY</code> 指令将文件和目录复制到容器的文件系统。文件和目录需位于相对于 <strong>Dockerfile</strong> 的路径中。</p>
<p>格式：</p>
<p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</code></p>
<p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</code></p>
<blockquote>
<p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
</blockquote>
<p>如果源或目标<strong>包含空格</strong>，请将路径括在<strong>方括号</strong>和<strong>双引号</strong>中。</p>
<p><code>&lt;目标路径&gt;</code>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p>
<h4 id="add">ADD</h4>
<p><code>ADD</code> 指令与 <code>COPY</code> 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，<code>ADD</code> 指令还可以使用 <strong>URL</strong> 规范从远程位置复制文件。</p>
<p>格式为：<code>ADD &lt;source&gt; &lt;destination&gt;</code></p>
<p><code>ADD https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe /temp/python-3.5.1.exe</code></p>
<p>此命令会将 <strong>Python for Windows</strong>下载到容器映像的 <code>c:\temp</code> 目录。</p>
<ul>
<li><code>ADD</code> 的优点：在执行 <code>&lt;源文件&gt;</code> 为 <strong>tar</strong> 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会<strong>自动复制并解压</strong>到 <code>&lt;目标路径&gt;</code>。</li>
</ul>
<ul>
<li><code>ADD</code> 的缺点：在不解压的前提下，无法复制 <strong>tar</strong> 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h4 id="workdir">WORKDIR</h4>
<p><code>WORKDIR</code> 指令用于为其他 <strong>Dockerfile 指令</strong>（如 <code>RUN</code>、<code>CMD</code>）设置一个工作目录，并且还设置用于运行容器映像<strong>实例的工作目录</strong>。</p>
<p>格式为：<code>WORKDIR &lt;目录&gt;</code></p>
<h4 id="env">ENV</h4>
<p>ENV命令用于<strong>设置环境变量</strong>。这些变量以<code>&lt;key&gt;=&lt;value&gt;</code>的形式存在，并<strong>可以在容器内被脚本或者程序调用</strong>。这个机制给在容器中运行应用带来了极大的便利。</p>
<p>格式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff79c6">ENV</span> &lt;key&gt; &lt;value&gt;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">ENV</span> &lt;key1&gt;<span style="color:#ff79c6">=</span>&lt;value1&gt; &lt;key2&gt;<span style="color:#ff79c6">=</span>&lt;value2&gt;...
</span></span></code></pre></div><p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff79c6">ENV</span> <span style="color:#8be9fd;font-style:italic">VERSION</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>.0 <span style="color:#8be9fd;font-style:italic">DEBUG</span><span style="color:#ff79c6">=</span>on <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>  <span style="color:#8be9fd;font-style:italic">NAME</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;Magicodes&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#后续的指令中可以通过 $VERSION $DEBUG $NAME 引用</span>
</span></span></code></pre></div><h4 id="arg">ARG</h4>
<p>构建参数，与 <code>ENV</code> 作用一致。不过作用域不一样。<code>ARG</code> 设置的环境变量<strong>仅对 Dockerfile 内有效</strong>，也就是说只有 <code>docker build</code> 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 <code>docker build</code> 中可以用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>格式为：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<h4 id="volume">VOLUME</h4>
<p><strong>定义匿名数据卷</strong>。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span><span style="color:#ff79c6">VOLUME</span> [<span style="color:#f1fa8c">&#34;&lt;路径1&gt;&#34;</span>, <span style="color:#f1fa8c">&#34;&lt;路径2&gt;&#34;</span>...]
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">VOLUME</span><span style="color:#f1fa8c"> &lt;路径&gt;</span>
</span></span></code></pre></div><p>在启动容器 <code>docker run</code> 的时候，我们可以通过 <code>-v</code> 参数<strong>修改挂载点</strong>。</p>
<h4 id="expose">EXPOSE</h4>
<p><strong>声明端口</strong></p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<p>格式：<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<h4 id="user">USER</h4>
<p><strong>切换后续命令执行的用户</strong>（用户和用户组<strong>必须提前已经存在</strong>）。</p>
<p>格式为：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<h4 id="healthcheck">HEALTHCHECK</h4>
<p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>HEALTHCHECK <span style="color:#ff79c6">[</span>选项<span style="color:#ff79c6">]</span> CMD &lt;命令&gt;：设置检查容器健康状况的命令
</span></span><span style="display:flex;"><span>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HEALTHCHECK <span style="color:#ff79c6">[</span>选项<span style="color:#ff79c6">]</span> CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。
</span></span></code></pre></div><h4 id="label">LABEL</h4>
<p><code>LABEL</code> 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p>
<p><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>
<p>比如可以添加镜像的作者：</p>
<p><code>LABEL org.opencontainers.image.authors=&quot;huzhiwen&quot;</code></p>
<h4 id="onbuild">ONBUILD</h4>
<p>用于延迟构建命令的执行。简单的说，就是 <strong>Dockerfile</strong> 里用 <code>ONBUILD</code> 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 <strong>test-build</strong>）。当有<strong>新的 Dockerfile</strong> 使用了之前构建的镜像 <code>FROM test-build</code> ，这时<strong>执行新镜像的 Dockerfile 构建</strong>时候，会执行 test-build 的 Dockerfile 里的 <code>ONBUILD</code> 指定的命令。</p>
<p><code>ONBUILD &lt;其它指令&gt;</code></p>
<h4 id="构建">构建</h4>
<p><code>docker build -t &lt;镜像名称[:镜像标签]&gt; &lt;镜像路径（.表示当前路径）&gt;</code></p>
<h2 id="实战部署nginx">实战（部署Nginx）</h2>

    </div>
    <div class="post-footer">
        <div class="info">
            
            <span class="separator"><a class="tag" href="/tags/computer/">computer</a><a class="tag" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></span>
        </div>
        


    </div>
    
        
    
</div>

                <div class="grow"></div>
                <div class="built-with">
    Built with <a href="https://gohugo.io/">Hugo</a> <b>·</b> Using the <a href="https://github.com/LucasVadilho/heyo-hugo-theme">heyo</a> theme
</div>
            </div>
        </div>
        
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha512-3M00D/rn8n+2ZVXBO9Hib0GKNpkm8MSUU/e2VNthDyBYxKWG+BftNYYcuEjXlyrSO637tidzMBXfE7sQm0INUg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<script type="text/javascript">
            
            
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$','$$'], ['\\[', '\\]']]
                },
                svg: {
                    scale: 1.25,
                }
            };
        </script><script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.0/es5/tex-mml-svg.min.js" integrity="sha512-/mL9Gs6E5Bz6NtPOr9eY&#43;T8IIdJbo2JL3TudApzFFelwBXEc3TeFLU6kPq122TJROv7jkktuBRkz5h8vGzrsyA==" crossorigin="anonymous"></script>
    </body>
</html>